using DCS.Compile.Operation;
using DCS.Compile.Token;
using DCS.Compile.Collection;
using DCS;
using DCS.DCSTables;
using DCS.Forms;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Text;
using System.Windows.Forms;
using DCS.Draw;
using System.Globalization;

namespace DCS.Compile
{
    class Compiler
    {
        //string m_strInput;
        //private List<string> M_TokenList;
        //public List<string> m_TokenList
        //{
        //    get
        //    {
        //        return M_TokenList;
        //    }
        //    set
        //    {
        //        M_TokenList = value;
        //    }
        //}
        MainForm parentMainForm;
        static Dictionary<int, int> compilervartypelist;
        
        static bool[,] typecounter = new bool[22,50];
        public static int GetUnassignedTempVar(int _type)
        {
            int _ty = Compiler.CompilerVarTypeList[_type];
            for (int i = 0; i < 50; i++)
            {
                if (Compiler.typecounter[_ty, i] == false)
                {
                    Compiler.typecounter[_ty, i] = true;
                    return i;
                }
            }
            throw new Exception("very complex expression");
            //return -1;
        }

        public static void FreeAssignedTempVar(int _type, int _index)
        {
            try
            {
                int _ty = Compiler.CompilerVarTypeList[_type];

                Compiler.typecounter[_ty, _index] = false;
            }
            catch (Exception ex)
            {
                throw ex;
            }
                    
        }
        public static Dictionary<int, int> CompilerVarTypeList
        {
            get
            {
                if (compilervartypelist == null)
                {
                    compilervartypelist = new Dictionary<int, int>();

                    compilervartypelist.Add((int)VarType.BOOL, 0);
                    compilervartypelist.Add((int)VarType.BYTE, 1);
                    compilervartypelist.Add((int)VarType.WORD, 2);
                    compilervartypelist.Add((int)VarType.DWORD, 3);
                    compilervartypelist.Add((int)VarType.LWORD, 4);
                    compilervartypelist.Add((int)VarType.SINT, 5);
                    compilervartypelist.Add((int)VarType.INT, 6);
                    compilervartypelist.Add((int)VarType.DINT, 7);
                    compilervartypelist.Add((int)VarType.LINT, 8);
                    compilervartypelist.Add((int)VarType.USINT, 9);
                    compilervartypelist.Add((int)VarType.UINT, 10);
                    compilervartypelist.Add((int)VarType.UDINT, 11);
                    compilervartypelist.Add((int)VarType.ULINT, 12);
                    compilervartypelist.Add((int)VarType.REAL, 13);
                    compilervartypelist.Add((int)VarType.LREAL, 14);
                    compilervartypelist.Add((int)VarType.DATE, 15);
                    compilervartypelist.Add((int)VarType.TOD, 16);
                    compilervartypelist.Add((int)VarType.DT, 17);
                    compilervartypelist.Add((int)VarType.STRING, 18);
                    compilervartypelist.Add((int)VarType.WSTRING, 19);
                    compilervartypelist.Add((int)VarType.TIME, 20);


                }
                return compilervartypelist;
            }
            //set
            //{
            //    stringvartypelist = value;
            //}
        }

        List<string> stringcollection = new List<string>();
        List<ValueObj> constantcollection = new List<ValueObj>();
        List<CToken> InfixTokenList = new List<CToken>();
        List<CToken> PRNTokenList = new List<CToken>();
        List<string> seperatedlist = new List<string>();

        //public int getfreeindex(int type)
        //{
        //    int i;
        //    i = tyoecounter[CompilerVarTypeList[type]];
        //    tyoecounter[CompilerVarTypeList[type]]++;
        //    return i;
        //}


        ///public bool Seperator(string _retsstring)
        bool Seperator(string m_strInput)
        {
            //char[] stringInput= m_strInput.ToArray ();
            int pt = m_strInput.Length;
            int i, j;
            string myseps = " ,+-*/() =:<>;";
            char[] seps = myseps.ToCharArray();

            string myseps1 = "\"";
            char[] seps1 = myseps1.ToCharArray();
            List<string> _Stack = new List<string>();
            //CStringArray _Stack;
            char cstr = m_strInput.ElementAt(1);
            //char cstr = m_strInput.GetBuffer(1);
            string strtmp = "";
            char ch;
            byte ch1;
            bool readingstring = false;
            //string ss = "\"";
            string ss1;
            seps[0] = '\t';
            m_strInput.ToLower();
            seperatedlist.Clear();
            //m_TokenList.RemoveAll();

            i = 0;

            //if (m_strInput == "")
            //{
            //    _retsstring = "Blank Expression";
            //    return false;
            //}

            while (i < m_strInput.Length)
            {
                ch = (char)m_strInput[i];
                ch1 = (byte)m_strInput[i];

                if (!readingstring)
                {
                    //if(cstr[i] == '"')
                    ss1 = m_strInput[i].ToString();
                    if (ss1 == "\"")
                    //if( IsSeperator( (char)m_strInput[i] ,seps1))
                    {
                        readingstring = true;
                        _Stack.Add((m_strInput[i].ToString()));
                    }
                    else
                    {
                        if (IsSeperator((char)m_strInput[i], seps))  // 1
                        {

                            if (_Stack.Count > 0)  // 2
                            {
                                j = 0;
                                strtmp = "";
                                do
                                {
                                    strtmp += _Stack.ElementAt(j++);
                                } while (j < _Stack.Count);
                                _Stack.Clear();
                                seperatedlist.Add(strtmp);
                            }  // 2
                            if (m_strInput[i] != ' ')  // 3
                            {
                                if (m_strInput[i] == '-') // 4
                                {
                                    //Homey-Changed 02/01/2014 
                                    //if((( i > 0) && ((m_strInput[i-1] == '(') ||(m_strInput[i-1] == '=')) ) || (i == 0)) 
                                    if (((i > 0) && ((m_strInput[i - 1] == '(') || (m_strInput[i - 1] == ',') || (m_strInput[i - 1] == '='))) || (i == 0))  // 5
                                    {
                                        _Stack.Add(m_strInput[i].ToString());
                                    }
                                    else // 5
                                    {
                                        seperatedlist.Add(m_strInput[i].ToString());
                                    } // 5
                                }
                                else // 4
                                {

                                    if (((i + 1) < ((int)m_strInput.Length)) && (((m_strInput[i] == ':') && (m_strInput[i + 1] == '=')) ||
                                        ((m_strInput[i] == '>') && (m_strInput[i + 1] == '=')) ||
                                        ((m_strInput[i] == '<') && (m_strInput[i + 1] == '=')) ||
                                        ((m_strInput[i] == '<') && (m_strInput[i + 1] == '>'))))
                                    {
                                        seperatedlist.Add((m_strInput[i].ToString()) + (m_strInput[i + 1].ToString()));
                                        i++;
                                    }
                                    else
                                    {
                                        seperatedlist.Add((m_strInput[i].ToString()));
                                    }
                                } // 4
                            }

                        }  // 1
                        else
                        {
                            _Stack.Add((m_strInput[i].ToString()));
                        }
                    }
                }
                else
                {
                    ss1 = m_strInput[i].ToString();
                    if (ss1 == "\"")
                    //if(m_strInput[i] == '\"')
                    {
                        readingstring = false;
                        _Stack.Add((m_strInput[i].ToString()));
                        j = 0;
                        strtmp = "";
                        do
                        {
                            strtmp += _Stack.ElementAt(j++);
                        } while (j < _Stack.Count);
                        _Stack.Clear();
                        seperatedlist.Add(strtmp);
                    }
                    else
                    {
                        _Stack.Add((m_strInput[i].ToString()));
                    }
                }
                i++;
            }
            if (_Stack.Count > 0)  // 2
            {
                j = 0;
                strtmp = "";
                do
                {
                    strtmp += _Stack.ElementAt(j++);
                } while (j < _Stack.Count);
                _Stack.Clear();
                seperatedlist.Add(strtmp);
            }  // 2


            return true;
        }
        private bool IsSeperator(char ch, char[] Seps)
        {
            if (!Seps.Contains(ch))
            //if( strchr( Seps, ch ) == NULL)
            {
                return false;
            }
            else
            {
                return true;
            }
        }


        private void PrintToken()
        {
            //string str;
            //CToken tok;



        }



        //char *seps   = {"0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"};
        //private bool IsValue(string _str, ref ValueObj _valueobj)
        private bool IsValue(string _str, ref ValueObj _valueobj)
        {
            //char * str = (char *) (LPCTSTR) _str.MakeLower();
            //wchar_t *str ;
            //str = _str.GetBuffer();
            //int withDecimal = 0;
            //int isNegative = 0;
            //int i = 0;
            //IPAddress.HostToNetworkOrder
            _str = _str.ToLower();
            int len = 0;
            string tempstr = "";

            if ((_str == "true") || (_str == "false"))
            {
                _valueobj.ValueType = (int)VarType.BOOL;

                if (_str == "true")
                {
                    _valueobj.Val.BOOL = true;
                }
                else
                {
                    _valueobj.Val.BOOL = false;
                }
                return true;
            }

            tempstr = "bool#";
            len = tempstr.Length;
            if ((_str.Length > len) && (_str.Substring(0, len) == tempstr))
            {
                string str1 = _str.Substring(len, _str.Length);
                //string str1 = _str.Mid(5,_str.Length);	
                if (IsValueBOOL(str1, ref _valueobj))
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }

            tempstr = "byte#";
            len = tempstr.Length;
            if ((_str.Length > len) && (_str.Substring(0, len) == tempstr))
            {
                string str1 = _str.Substring(len, _str.Length);

                if (CheckValue(str1, ref _valueobj))
                {
                    if (IsValueBYTE(str1, ref _valueobj))
                    {
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }

            }

            tempstr = "word#";
            len = tempstr.Length;
            if ((_str.Length > len) && (_str.Substring(0, len) == tempstr))
            {
                string str1 = _str.Substring(len, _str.Length);

                if (CheckValue(str1, ref _valueobj))
                {
                    if (IsValueWORD(str1, ref _valueobj))
                    {
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }

            }

            tempstr = "dword#";
            len = tempstr.Length;
            if ((_str.Length > len) && (_str.Substring(0, len) == tempstr))
            {
                string str1 = _str.Substring(len, _str.Length);
                if (CheckValue(str1, ref _valueobj))
                {
                    if (IsValueDWORD(str1, ref _valueobj))
                    {
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }

            }

            tempstr = "lword#";
            len = tempstr.Length;
            if ((_str.Length > len) && (_str.Substring(0, len) == tempstr))
            {
                string str1 = _str.Substring(len, _str.Length);
                if (CheckValue(str1, ref _valueobj))
                {
                    if (IsValueLWORD(str1, ref _valueobj))
                    {
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }

            }

            tempstr = "sint#";
            len = tempstr.Length;
            if ((_str.Length > len) && (_str.Substring(0, len) == tempstr))
            {
                string str1 = _str.Substring(len, _str.Length);
                if (CheckValue(str1, ref _valueobj))
                {
                    if (IsValueSINT(str1, ref _valueobj))
                    {
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }

            }

            tempstr = "int#";
            len = tempstr.Length;
            if ((_str.Length > len) && (_str.Substring(0, len) == tempstr))
            {
                string str1 = _str.Substring(len, _str.Length);
                if (CheckValue(str1, ref _valueobj))
                {
                    if (IsValueINT(str1, ref _valueobj))
                    {
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }

            }

            tempstr = "dint#";
            len = tempstr.Length;
            if ((_str.Length > len) && (_str.Substring(0, len) == tempstr))
            {
                string str1 = _str.Substring(len, _str.Length);
                if (CheckValue(str1, ref _valueobj))
                {
                    if (IsValueDINT(str1, ref _valueobj))
                    {
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }

            }

            tempstr = "lint#";
            len = tempstr.Length;
            if ((_str.Length > len) && (_str.Substring(0, len) == tempstr))
            {
                string str1 = _str.Substring(len, _str.Length);
                if (CheckValue(str1, ref _valueobj))
                {
                    if (IsValueLINT(str1, ref _valueobj))
                    {
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }

            }

            tempstr = "usint#";
            len = tempstr.Length;
            if ((_str.Length > len) && (_str.Substring(0, len) == tempstr))
            {
                string str1 = _str.Substring(len, _str.Length);
                if (CheckValue(str1, ref _valueobj))
                {
                    if (IsValueUSINT(str1, ref _valueobj))
                    {
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }

            }

            tempstr = "uint#";
            len = tempstr.Length;
            if ((_str.Length > len) && (_str.Substring(0, len) == tempstr))
            {
                string str1 = _str.Substring(len, _str.Length);
                if (CheckValue(str1, ref _valueobj))
                {
                    if (IsValueUINT(str1, ref _valueobj))
                    {
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }

            }

            tempstr = "udint#";
            len = tempstr.Length;
            if ((_str.Length > len) && (_str.Substring(0, len) == tempstr))
            {
                string str1 = _str.Substring(len, _str.Length);
                if (CheckValue(str1, ref _valueobj))
                {
                    if (IsValueUDINT(str1, ref _valueobj))
                    {
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }

            }

            tempstr = "ulint#";
            len = tempstr.Length;
            if ((_str.Length > len) && (_str.Substring(0, len) == tempstr))
            {
                string str1 = _str.Substring(len, _str.Length);
                if (CheckValue(str1, ref _valueobj))
                {
                    if (IsValueULINT(str1, ref _valueobj))
                    {
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }

            }

            tempstr = "real#";
            len = tempstr.Length;
            if ((_str.Length > len) && (_str.Substring(0, len) == tempstr))
            {
                string str1 = _str.Substring(len, _str.Length);
                if (CheckValue(str1, ref _valueobj))
                {
                    if (IsValuefloat(str1, ref _valueobj))
                    {
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }

            }
            tempstr = "lreal#";
            len = tempstr.Length;
            if ((_str.Length > len) && (_str.Substring(0, len) == tempstr))
            {
                string str1 = _str.Substring(len, _str.Length);
                if (CheckValue(str1, ref _valueobj))
                {
                    if (IsValueLREAL(str1, ref _valueobj))
                    {
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }

            }


            tempstr = "time#";
            len = tempstr.Length;
            if ((_str.Length > len) && (_str.Substring(0, len) == tempstr))
            {
                string str1 = _str.Substring(len, _str.Length);
                if (IsValueTIME(str1, ref _valueobj))
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }
            tempstr = "t#";
            len = tempstr.Length;
            if ((_str.Length > len) && (_str.Substring(0, len) == tempstr))
            {
                string str1 = _str.Substring(len, _str.Length);
                if (IsValueTIME(str1, ref _valueobj))
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }

            tempstr = "date#";
            len = tempstr.Length;
            if ((_str.Length > len) && (_str.Substring(0, len) == tempstr))
            {
                string str1 = _str.Substring(len, _str.Length);
                if (CheckValue(str1, ref _valueobj))
                {
                    if (IsValueDATE(str1, ref _valueobj))
                    {
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }

            }

            tempstr = "tod#";
            len = tempstr.Length;
            if ((_str.Length > len) && (_str.Substring(0, len) == tempstr))
            {
                string str1 = _str.Substring(len, _str.Length);
                if (CheckValue(str1, ref _valueobj))
                {
                    if (IsValueTOD(str1, ref _valueobj))
                    {
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }

            }

            tempstr = "dt#";
            len = tempstr.Length;
            if ((_str.Length > len) && (_str.Substring(0, len) == tempstr))
            {
                string str1 = _str.Substring(len, _str.Length);
                if (CheckValue(str1, ref _valueobj))
                {
                    if (IsValueDT(str1, ref _valueobj))
                    {
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }

            }

            tempstr = "col#";
            len = tempstr.Length;
            if ((_str.Length > len) && (_str.Substring(0, len) == tempstr))
            {
                string str1 = _str.Substring(len, _str.Length);
                if (IsValueColor(str1, ref _valueobj))
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }

            if (CheckValue(_str, ref _valueobj))
            {
                return true;
            }
            else
            {
                return false;
            }
            //return false;
        }
        private bool IsStringValue(string _str, ref string _str1)
        {
            //char * str = (char *) (LPCTSTR) _str.MakeLower();
            //char str ;
            //str = _str.GetBuffer();
            //int withDecimal = 0;
            //int isNegative = 0;
            //int i = 0;
            if ((_str.Substring(0, 1) == "\"") && (_str.Substring(_str.Length - 1, _str.Length) == "\""))
            {
                _str1 = _str.Substring(1, _str.Length - 2);
                return true;
            }
            else
            {
                return false;
            }

        }
        private bool StringIsBase2(string _str, ref ValueObj _valueobj)
        {
            //	char   *string, *stopstring;
            int i = 0;
            int j = 0;
            int len = _str.Length;
            char[] str;
            str = _str.ToCharArray();

            if ((len == 1) && (str[0] == '-'))
            {
                return false;
            }
            if (str[0] == '-')
            {
                j = 1;
            }
            else
            {
                j = 0;
            }
            for (i = j; i < len; i++)
            {
                if (!((str[i] == '0') || (str[i] == '1'))) // if1
                {
                    return false;
                }
            }
            char start = (char)str[j];
            int total = 0;
            for (i = j; i < len; i++)
            {
                start = (char)str[j];
                total = 0;
                while (start != null)
                {
                    total *= 2;
                    if (start++ == '1') total += 1;
                }
            }
            if (j == 1)
            {
                _valueobj.Val.DINT = -1 * total;
            }
            else
            {
                _valueobj.Val.DINT = total;
            }
            return false;
        }
        private bool StringIsBase8(string _str, ref ValueObj _valueobj)
        {
            //	char   *string, *stopstring;
            int i = 0;
            int j = 0;
            int len = _str.Length;
            char[] str;
            str = _str.ToCharArray();

            if ((len == 1) && (str[0] == '-'))
            {
                return false;
            }
            if (str[0] == '-')
            {
                j = 1;
            }
            else
            {
                j = 0;
            }
            for (i = j; i < len; i++)
            {
                if (!((str[i] == '0') || (str[i] == '1') || (str[i] == '2') || (str[i] == '3') || (str[i] == '4') || (str[i] == '5') || (str[i] == '6') || (str[i] == '7'))) // if1
                {
                    return false;
                }
            }
            char start = (char)str[j];
            int total = 0;
            for (i = j; i < len; i++)
            {
                start = (char)str[j];
                total = 0;
                while (start != null)
                {
                    total *= 8;
                    switch (start)
                    {
                        case '1':
                            total += 1;
                            break;
                        case '2':
                            total += 2;
                            break;
                        case '3':
                            total += 3;
                            break;
                        case '4':
                            total += 4;
                            break;
                        case '5':
                            total += 5;
                            break;
                        case '6':
                            total += 6;
                            break;
                        case '7':
                            total += 7;
                            break;

                        default:
                            break;
                    }

                }
            }
            if (j == 1)
            {
                _valueobj.Val.DINT = -1 * total;
            }
            else
            {
                _valueobj.Val.DINT = total;
            }
            return false;
        }
        private bool StringIsBase10(string _str, ref ValueObj _valueobj)
        {
            //	char   *string, *stopstring;
            int i = 0;
            int j = 0;
            int len = _str.Length;
            char[] str;
            str = _str.ToCharArray();

            if ((len == 1) && (str[0] == '-'))
            {
                return false;
            }
            if (str[0] == '-')
            {
                j = 1;
            }
            else
            {
                j = 0;
            }
            for (i = j; i < len; i++)
            {
                if (!((str[i] == '0') || (str[i] == '1') || (str[i] == '2') || (str[i] == '3') || (str[i] == '4') || (str[i] == '5') || (str[i] == '6') || (str[i] == '7'))) // if1
                {
                    return false;
                }
            }
            char start = (char)str[j];
            int total = 0;
            for (i = j; i < len; i++)
            {
                start = (char)str[j];
                total = 0;
                while (start != null)
                {
                    total *= 10;
                    switch (start)
                    {
                        case '1':
                            total += 1;
                            break;
                        case '2':
                            total += 2;
                            break;
                        case '3':
                            total += 3;
                            break;
                        case '4':
                            total += 4;
                            break;
                        case '5':
                            total += 5;
                            break;
                        case '6':
                            total += 6;
                            break;
                        case '7':
                            total += 7;
                            break;

                        default:
                            break;
                    }

                }
            }
            if (j == 1)
            {
                _valueobj.Val.DINT = -1 * total;
            }
            else
            {
                _valueobj.Val.DINT = total;
            }
            return false;
        }
        private bool StringIsBase16(string _str, ref ValueObj _valueobj)
        {
            //	char   *string, *stopstring;
            int i = 0;
            int j = 0;
            int len = _str.Length;
            char[] str;
            str = _str.ToCharArray();

            if ((len == 1) && (str[0] == '-'))
            {
                return false;
            }
            if (str[0] == '-')
            {
                j = 1;
            }
            else
            {
                j = 0;
            }
            for (i = j; i < len; i++)
            {
                if ((str[i] == '0') || (str[i] == '1')) // if1
                {
                    char start = (char)str[j];
                    int total = 0;
                    while (start != null)
                    {
                        total *= 2;
                        if (start++ == '1')
                            total += 1;
                    }
                }
            }
            return false;
        }
        private bool ProcessValueString(string _str, ref ValueObj _valueobj)
        {
            if (_str.Substring(0, 2) == "2#")
            {
                string str1 = _str.Substring(2, _str.Length);
                if (IsValueBOOL(str1, ref _valueobj))
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }
            return false;
        }

        private bool IsValueColor(string _str, ref ValueObj _valueobj)
        {
            if (_str == "aliceblue") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xF0F8FF; return true; }
            if (_str == "antiquewhite") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFAEBD7; return true; }
            if (_str == "aqua") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x00FFFF; return true; }
            if (_str == "aquamarine") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x7FFFD4; return true; }
            if (_str == "azure") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xF0FFFF; return true; }
            if (_str == "beige") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xF5F5DC; return true; }
            if (_str == "bisque") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFFE4C4; return true; }
            if (_str == "black") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x000000; return true; }
            if (_str == "blanchedalmond") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFFEBCD; return true; }
            if (_str == "blue") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x0000FF; return true; }
            if (_str == "blueviolet") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x8A2BE2; return true; }
            if (_str == "brown") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xA52A2A; return true; }
            if (_str == "burlywood") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xDEB887; return true; }
            if (_str == "cadetblue") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x5F9EA0; return true; }
            if (_str == "chartreuse") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x7FFF00; return true; }
            if (_str == "chocolate") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xD2691E; return true; }
            if (_str == "coral") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFF7F50; return true; }
            if (_str == "cornflowerblue") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x6495ED; return true; }
            if (_str == "cornsilk") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFFF8DC; return true; }
            if (_str == "crimson") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xDC143C; return true; }
            if (_str == "cyan") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x00FFFF; return true; }
            if (_str == "darkblue") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x00008B; return true; }
            if (_str == "darkcyan") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x008B8B; return true; }
            if (_str == "darkgoldenrod") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xB8860B; return true; }
            if (_str == "darkgray") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xA9A9A9; return true; }
            if (_str == "darkgreen") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x006400; return true; }
            if (_str == "darkkhaki") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xBDB76B; return true; }
            if (_str == "darkmagenta") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x8B008B; return true; }
            if (_str == "darkolivegreen") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x556B2F; return true; }
            if (_str == "darkorange") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFF8C00; return true; }
            if (_str == "darkorchid") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x9932CC; return true; }
            if (_str == "darkred") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x8B0000; return true; }
            if (_str == "darksalmon") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xE9967A; return true; }
            if (_str == "darkseagreen") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x8FBC8F; return true; }
            if (_str == "darkslateblue") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x483D8B; return true; }
            if (_str == "darkslategray") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x2F4F4F; return true; }
            if (_str == "darkturquoise") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x00CED1; return true; }
            if (_str == "darkviolet") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x9400D3; return true; }
            if (_str == "deeppink") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFF1493; return true; }
            if (_str == "deepskyblue") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x00BFFF; return true; }
            if (_str == "dimgray") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x404040; return true; }
            if (_str == "dimgrey") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x404040; return true; }
            if (_str == "dodgerblue") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x1E90FF; return true; }
            if (_str == "firebrick") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xB22222; return true; }
            if (_str == "floralwhite") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFFFAF0; return true; }
            if (_str == "forestgreen") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x228B22; return true; }
            if (_str == "fuchsia") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFF00FF; return true; }
            if (_str == "gainsboro") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xDCDCDC; return true; }
            if (_str == "ghostwhite") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xF8F8FF; return true; }
            if (_str == "gold") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFFD700; return true; }
            if (_str == "goldenrod") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xDAA520; return true; }
            if (_str == "gray") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x808080; return true; }
            if (_str == "green") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x008000; return true; }
            if (_str == "greenyellow") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xADFF2F; return true; }
            if (_str == "honeydew") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xF0FFF0; return true; }
            if (_str == "hotpink") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFF69B4; return true; }
            if (_str == "indianred") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xCD5C5C; return true; }
            if (_str == "indigo") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x4B0082; return true; }
            if (_str == "ivory") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFFFFF0; return true; }
            if (_str == "khaki") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xF0E68C; return true; }
            if (_str == "lavender") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xE6E6FA; return true; }
            if (_str == "lavenderblush") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFFF0F5; return true; }
            if (_str == "lawngreen") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x7CFC00; return true; }
            if (_str == "lemonchiffon") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFFFACD; return true; }
            if (_str == "lightblue") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xADD8E6; return true; }
            if (_str == "lightcoral") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xF08080; return true; }
            if (_str == "lightcyan") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xE0FFFF; return true; }
            if (_str == "lightgoldenrodyellow") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFAFAD2; return true; }
            if (_str == "lightgray") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xD3D3D3; return true; }
            if (_str == "lightgreen") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x90EE90; return true; }
            if (_str == "lightpink") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFFB6C1; return true; }
            if (_str == "lightsalmon") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFFA07A; return true; }
            if (_str == "lightseagreen") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x20B2AA; return true; }
            if (_str == "lightskyblue") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x87CEFA; return true; }
            if (_str == "lightslategray") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x778899; return true; }
            if (_str == "lightsteelblue") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xB0C4DE; return true; }
            if (_str == "lightyellow") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFFFFE0; return true; }
            if (_str == "lime") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x00FF00; return true; }
            if (_str == "limegreen") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x32CD32; return true; }
            if (_str == "linen") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFAF0E6; return true; }
            if (_str == "magenta") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFF00FF; return true; }
            if (_str == "maroon") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x800000; return true; }
            if (_str == "mediumaquamarine") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x66CDAA; return true; }
            if (_str == "mediumblue") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x0000CD; return true; }
            if (_str == "mediumorchid") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xBA55D3; return true; }
            if (_str == "mediumpurple") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x9370DB; return true; }
            if (_str == "mediumseagreen") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x3CB371; return true; }
            if (_str == "mediumslateblue") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x7B68EE; return true; }
            if (_str == "mediumspringgreen") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x00FA9A; return true; }
            if (_str == "mediumturquoise") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x48D1CC; return true; }
            if (_str == "mediumvioletred") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xC71585; return true; }
            if (_str == "midnightblue") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x191970; return true; }
            if (_str == "mintcream") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xF5FFFA; return true; }
            if (_str == "mistyrose") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFFE4E1; return true; }
            if (_str == "moccasin") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFFE4B5; return true; }
            if (_str == "navajowhite") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFFDEAD; return true; }
            if (_str == "navy") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x000080; return true; }
            if (_str == "oldlace") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFDF5E6; return true; }
            if (_str == "olive") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x808000; return true; }
            if (_str == "olivedrab") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x6B8E23; return true; }
            if (_str == "orange") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFFA500; return true; }
            if (_str == "orangered") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFF4500; return true; }
            if (_str == "orchid") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xDA70D6; return true; }
            if (_str == "palegoldenrod") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xEEE8AA; return true; }
            if (_str == "palegreen") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x98FB98; return true; }
            if (_str == "paleturquoise") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xAFEEEE; return true; }
            if (_str == "palevioletred") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xDB7093; return true; }
            if (_str == "papayawhip") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFFEFD5; return true; }
            if (_str == "peachpuff") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFFDAB9; return true; }
            if (_str == "peru") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xCD853F; return true; }
            if (_str == "pink") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFFC0CB; return true; }
            if (_str == "plum") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xDDA0DD; return true; }
            if (_str == "powderblue") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xB0E0E6; return true; }
            if (_str == "purple") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x800080; return true; }
            if (_str == "red") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFF0000; return true; }
            if (_str == "rosybrown") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xBC8F8F; return true; }
            if (_str == "royalblue") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x4169E1; return true; }
            if (_str == "saddlebrown") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x8B4513; return true; }
            if (_str == "salmon") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFA8072; return true; }
            if (_str == "sandybrown") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xF4A460; return true; }
            if (_str == "seagreen") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x2E8B57; return true; }
            if (_str == "seashell") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFFF5EE; return true; }
            if (_str == "sienna") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xA0522D; return true; }
            if (_str == "silver") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xC0C0C0; return true; }
            if (_str == "skyblue") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x87CEEB; return true; }
            if (_str == "slateblue") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x6A5ACD; return true; }
            if (_str == "slategray") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x708090; return true; }
            if (_str == "snow") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFFFAFA; return true; }
            if (_str == "springgreen") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x00FF7F; return true; }
            if (_str == "steelblue") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x4682B4; return true; }
            if (_str == "tan") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xD2B48C; return true; }
            if (_str == "teal") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x008080; return true; }
            if (_str == "thistle") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xD8BFD8; return true; }
            if (_str == "tomato") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFF6347; return true; }
            if (_str == "turquoise") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x40E0D0; return true; }
            if (_str == "violet") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xEE82EE; return true; }
            if (_str == "wheat") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xF5DEB3; return true; }
            if (_str == "white") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFFFFFF; return true; }
            if (_str == "whitesmoke") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xF5F5F5; return true; }
            if (_str == "yellow") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xFFFF00; return true; }
            if (_str == "yellowgreen") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0x9ACD32; return true; }
            if (_str == "transparent") { _valueobj.ValueType = (int)VarType.UDINT; _valueobj.Val.UDINT = 0xffffffff; return true; }

            SendOutput("Error: definition of BOOL value is incorrect :" + _str);
            return false;
        }
        static private bool IsValueBOOL(string _str, ref ValueObj _valueobj)
        {
            if ((_str == "0") || (_str == "false"))
            {
                _valueobj.ValueType = (int)VarType.BOOL;
                _valueobj.Val.BOOL = false;
                return true;
            }
            if ((_str == "1") || (_str == "true"))
            {
                _valueobj.ValueType = (int)VarType.BOOL;
                _valueobj.Val.BOOL = true;
                return true;
            }
            //SendOutput("Error: definition of BOOL value is incorrect :" + _str);
            return false;
        }
        static bool IsValueBYTE(string _str, ref ValueObj _valueobj)
        {
            return true;
        }
        static bool IsValueWORD(string _str, ref ValueObj _valueobj)
        {
            return true;
        }
        static bool IsValueDWORD(string _str, ref ValueObj _valueobj)
        {
            return true;
        }
        static bool IsValueLWORD(string _str, ref ValueObj _valueobj) { return true; }
        static bool IsValueSINT(string _str, ref ValueObj _valueobj) { return true; }
        static bool IsValueINT(string _str, ref ValueObj _valueobj) { return true; }
        static bool IsValueDINT(string _str, ref ValueObj _valueobj) { return true; }
        static bool IsValueLINT(string _str, ref ValueObj _valueobj) { return true; }
        static bool IsValueUSINT(string _str, ref ValueObj _valueobj) { return true; }
        static bool IsValueUINT(string _str, ref ValueObj _valueobj) { return true; }
        static bool IsValueUDINT(string _str, ref ValueObj _valueobj) { return true; }
        static bool IsValueULINT(string _str, ref ValueObj _valueobj) { return true; }
        static bool IsValueREAL(string _str, ref ValueObj _valueobj) { return true; }
        static bool IsValueLREAL(string _str, ref ValueObj _valueobj) { return true; }
        static bool IsValueTIME(string _str, ref ValueObj _valueobj)
        {
            VALUE _val = new VALUE();

            bool noerror = true;
            string str = "";
            int i;
            int j;
            //int k;
            float _day = 0;
            float _hour = 0;
            float _minute = 0;
            float _second = 0;
            float _milisecond = 0;
            float temp = 0;
            _valueobj.ValueType = (int)VarType.TIME;

            int len = _str.Length;
            if (len >= 2)
            {
                j = 0;
                i = j;

               // k = 0;
                while ((_str[i] != 'd') && (i < len))
                {
                    str += _str[i];
                    i++;
                }

                if (i < len)
                {
                    _val.DWORD = 0;
                    if (CheckValue(str, ref _valueobj))
                    {
                        if (_valueobj.ValueType == (int)VarType.REAL)
                        {
                            _day = _val.REAL;
                        }
                        else
                        {
                            _day = (float)_val.DINT;
                        }
                        i++;
                        j = i;
                    }
                    else
                    {
                        noerror = false;
                    }
                }
                else
                {
                    i = j;
                }
                if (noerror)
                {
                    //i = j;
                    str = "";
                   // k = 0;
                    while ((_str[i] != 'h') && (i < len))
                    {
                        str += _str[i];
                        i++;
                    }

                    if (i < len)
                    {
                        if (CheckValue(str, ref _valueobj))
                        {
                            if (_valueobj.ValueType == (int)VarType.REAL)
                            {
                                _hour = _val.REAL;
                            }
                            else
                            {
                                _hour = (float)_val.DINT;
                            }
                            i++;
                            j = i;
                        }
                        else
                        {
                            noerror = false;
                        }
                    }
                    else
                    {
                        i = j;
                    }
                }

                if (noerror)
                {

                    str = "";
                   // k = 0;
                    while ((_str[i] != 'm') && (i < len))
                    {
                        str += _str[i];
                        i++;
                    }

                    if (i < len)
                    {
                        if (CheckValue(str, ref _valueobj))
                        {
                            if (_valueobj.ValueType == (int)VarType.REAL)
                            {
                                _minute = _val.REAL;
                            }
                            else
                            {
                                _minute = (float)_val.DINT;
                            }
                            i++;
                            j = i;
                        }
                        else
                        {
                            noerror = false;
                        }
                    }
                    else
                    {
                        i = j;
                    }
                }

                if (noerror)
                {

                    str = "";
                   // k = 0;
                    while ((_str[i] != 's') && (i < len))
                    {
                        str += _str[i];
                        i++;
                    }

                    if (i < len)
                    {
                        if (CheckValue(str, ref _valueobj))
                        {
                            if (_valueobj.ValueType == (int)VarType.REAL)
                            {
                                _second = _val.REAL;
                            }
                            else
                            {
                                _second = (float)_val.DINT;
                            }
                            i++;
                            j = i;
                        }
                        else
                        {
                            noerror = false;
                        }
                    }
                    else
                    {
                        i = j;
                    }
                }

                if (noerror)
                {

                    str = "";
                    while ((_str[i] != 'm') && (_str[i] != 's') && (i < len))
                    {
                        str += _str[i];
                        i++;
                    }

                    if (i < len)
                    {
                        if (CheckValue(str, ref _valueobj))
                        {
                            if (_valueobj.ValueType == (int)VarType.REAL)
                            {
                                _milisecond = _val.REAL;
                            }
                            else
                            {
                                _milisecond = (float)_val.DINT;
                            }
                            i++;
                            j = i;
                        }
                        else
                        {
                            noerror = false;
                        }
                    }
                    else
                    {
                        i = j;
                    }
                }

                if (noerror)
                {
                    //temp = _day;
                    //temp *= 24;
                    //temp += _hour;
                    //temp *= 60;
                    //temp += _minute;
                    //temp *= 60;
                    //temp += _second;
                    //temp *= 1000;
                    //temp += _milisecond;
                    temp = ((((((_day * 24) + _hour) * 60) + _minute) * 60) + _second) * 1000;// + _milisecond; 
                    _valueobj.Val.TIME = (uint)temp;
                    _valueobj.ValueType = (int)VarType.TIME;
                    return true;
                }
            }

            return false;
        }
        static bool IsValueDATE(string _str, ref ValueObj _valueobj)
        {
            return true;
        }
        static bool IsValueTOD(string _str, ref ValueObj _valueobj)
        {
            return true;
        }
        static bool IsValueDT(string _str, ref ValueObj _valueobj)
        {
            return true;
        }

        static bool IsValueint(string _str, ref ValueObj _valueobj)
        {
            try
            {
                _valueobj.Val.DINT = int.Parse(_str, NumberStyles.Integer);
                _valueobj.ValueType = (int)VarType.DINT;
                return true;
            }
            catch (FormatException)
            {

            }
            return false;
        }

        static bool IsValuefloat(string _str, ref ValueObj _valueobj)
        {
            try
            {
                _valueobj.Val.REAL = float.Parse(_str, NumberStyles.Float);
                _valueobj.ValueType = (int)VarType.REAL;
                return true;
            }
            catch (FormatException)
            {

            }

            return false;
        }

        static bool CheckValue(string _str, ref ValueObj _valueobj)
        {
            try
            {
                _valueobj.Val.DINT = int.Parse(_str, NumberStyles.Integer);
                _valueobj.ValueType = (int)VarType.DINT;
                return true;
            }
            catch (FormatException)
            {

            }
            try
            {
                _valueobj.Val.REAL = float.Parse(_str, NumberStyles.Float);
                _valueobj.ValueType = (int)VarType.REAL;
                return true;
            }
            catch (FormatException)
            {

            }

            return false;

        }

        bool IsFunction(string _str, ref tblFunction _tblfunction)
        {
            bool _found = false;
            foreach (tblFunction tblfunction in Global.EWS.m_tblSolution.m_tblFunctionCollection)
            {
                if ((tblfunction.IsFunction) && (tblfunction.FunctionName.ToLower() == _str.ToLower()))
                {
                    _tblfunction = tblfunction;
                    _found = true;
                    break;
                }
            }
            return _found;
        }

        bool IsOperator(string _str)
        {
            if ((_str == "!") ||
                (_str == "*") ||
                (_str == "/") ||
                (_str == "%") ||
                (_str == "+") ||
                (_str == "-") ||
                (_str == ">") ||
                (_str == "<") ||
                (_str == "=") ||
                (_str == "<>") ||
                (_str == ">=") ||
                (_str == "<=") ||
                (_str == "or") ||
                (_str == "and") ||
                (_str == "xor") ||
                (_str == ":=") ||
                (_str == ";"))
                return true;
            return false;
        }

        bool IsSeperator(string _str)
        {
            if ((_str == ")") ||
                (_str == "(") ||
                (_str == ","))
                return true;

            return false;
        }

        public void SendOutput(string _str)
        {
            Console.WriteLine(_str.ToString() + "  ");
            Console.WriteLine();


            //	throw  exception(_str.GetBuffer());
        }

        public void SendOutput(char _str)
        {
            Console.WriteLine(_str);
            Console.WriteLine();
            //throw  exception(_str);
        }

        bool IsFunctionBlockInstance(string _str, tblController _tblcontroller, tblPou _tblpou, ref tblVariable _tblvariable)
        {
            //bool _varexist = false;
           // int i = 0;

            //string resToken;
            //int curPos = 0;
            //int _varindex;

            //	int propertynum;
            //	VarType propertytype;
            int count = 0;
            string[] varname = _str.Split(new Char[] { '.' });
            count = varname.Count();
            if (varname != null)
            {
                if (count == 1)   // name only
                {
                    foreach (tblVariable tblvariable in _tblpou.m_tblVariableCollection)
                    {
                        if (tblvariable.VarName.ToLower() == varname[0].ToLower())
                        {
                            _tblvariable = tblvariable;
                            return true;
                        }
                    }
                    foreach (tblPou tblpou in _tblcontroller.m_tblPouCollection)
                    {
                        if (tblpou.pouName == "GLOBAL")
                        {
                            foreach (tblVariable tblvariable in tblpou.m_tblVariableCollection)
                            {
                                if (tblvariable.VarName.ToLower() == varname[0].ToLower())
                                {
                                    _tblvariable = tblvariable;
                                    return true;
                                }
                            }
                        }
                    }
                }
                else
                {
                    if (count == 3)  //name and property
                    {
                        foreach (tblController tblcontroller in Global.EWS.m_tblSolution.m_tblControllerCollection)
                        {
                            if ((tblcontroller.type == 0) && (tblcontroller.ControllerName.ToLower() == varname[1].ToLower()))
                            {
                                foreach (tblPou tblpou in tblcontroller.m_tblPouCollection)
                                {
                                    if (tblpou.pouName == "GLOBAL")
                                    {
                                        foreach (tblVariable tblvariable in tblpou.m_tblVariableCollection)
                                        {
                                            if (tblvariable.VarName.ToLower() == varname[2].ToLower())
                                            {
                                                _tblvariable = tblvariable;
                                                return true;
                                            }
                                        }
                                    }
                                }
                            }
                        }

                    }
                    else
                    {

                    }
                }
            }

            //char []str1 = varname.ToCharArray ();
            //string str11 = new string(str1);
            //DBKernel.VarType _vtype = DBKernel.VarType.UNKNOWN;
            //if( ( _poutype == POUTYPE.ENUM_POUTYPE_FUNCTION ) || (_poutype == POUTYPE.ENUM_POUTYPE_FUNCTIONBLOCK))
            //{
            //    _varexist = DBKernel.Model.FormalParameter.Search(str11,_vtype,_oindex,_functionID);
            //}
            //else
            //{
            //    if(_nodeid != -1)
            //    {
            //        _varexist = DBKernel::Model::Variable::Search(str11,_vtype,_oindex,_nodeid, _pouoindex);
            //        if(!_varexist)
            //        {
            //            _varexist = DBKernel::Model::Variable::Search(str11,_vtype,_oindex,_nodeid, 0);
            //        }
            //    }
            //    else
            //    {
            //        _varexist = DBKernel::Model::Variable::Search(str11,_vtype,_oindex,_nodeno);
            //    }

            //}
            //if(_varexist)
            //{
            //    _type = (VarType)_vtype;
            //    _propertyname = _str.Tokenize(_T("."),curPos);
            //    if( (_propertyname != _T("")) )
            //    {
            //        if(_propertyname.Find(_T('.'), 0) > 0)
            //        {
            //            return false;
            //        }
            //        else
            //        {
            //            char *str = _propertyname.GetBuffer();
            //            System::string^ str1 = gcnew System::string(str);
            //            DBKernel::VarType _temppropertyvartype = DBKernel::VarType::UNKNOWN;
            //            DBKernel::VarType _tempvartype = (DBKernel::VarType) _type;
            //            //if( m_tblVariableCollection->Get(_varindex)->ProprtyExist(this->m_ConnectionString, str1,_tempVartype,propertynum))
            //            if( DBKernel::Model::Variable::ProprtyExist(str1,_tempvartype,_temppropertyvartype,_propertynum))
            //            {
            //                _propertytype = (VarType)_temppropertyvartype;
            //                return true;
            //            }
            //        }
            //    }
            //    else
            //    {
            //        DBKernel::VarType _temppropertyvartype = DBKernel::VarType::UNKNOWN;
            //        DBKernel::VarType _tempvartype = (DBKernel::VarType) _type;
            //        if( DBKernel::Model::Variable::ProprtyExist("VAL",_tempvartype,_temppropertyvartype,_propertynum))
            //        {
            //            _propertytype = (VarType)_temppropertyvartype;
            //            return true;
            //        }
            //    }
            //}



            return false;
        }

        bool IsVariable(string _str, tblController _tblcontroller, tblPou _tblpou, ref tblVariable _tblvariable, ref tblFormalParameter _tblformalparameter, ref byte _subproperty, ref string _subpropertytxt)
        {
            try
            {
                if (_tblpou != null)
                {
                    if (_tblpou.IsVariable(_str, ref _tblvariable, ref _tblformalparameter, ref _subpropertytxt, ref _subproperty))
                    {
                        return true;
                    }
                    else
                    {
                        if (_tblcontroller.GetGlobalPOU().IsVariable(_str, ref _tblvariable, ref _tblformalparameter, ref _subpropertytxt, ref _subproperty))
                        {
                            return true;
                        }
                        else
                        {

                        }
                    }
                }
                else
                {
                    foreach (tblController tblcontroller in Global.EWS.m_tblSolution.m_tblControllerCollection)
                    {
                        if (tblcontroller.GetGlobalPOU().IsVariable(_str, ref _tblvariable, ref _tblformalparameter, ref _subpropertytxt, ref _subproperty))
                        {
                            return true;
                        }
                    }
                }
                return false;
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.Message);
            }
            return false;
        }

        int op_preced(string str)
        {

            //1 14	()   []   ->   .   ::	Grouping, scope, array/member access
            if ((str == "[") || (str == "]"))
                return 14;
            //2 13	 !   ~   -   +   *   &   sizeof   type cast ++x   --x  	(most) unary operations, sizeof and type casts
            if ((str == "!"))
                return 13;
            //3 12	*   /   %	Multiplication, division, modulo
            if ((str == "*") || (str == "/"))
                return 12;
            //4 11	+   -	Addition and subtraction
            if ((str == "+") || (str == "-"))
                return 11;
            //5 10	<<   >>	Bitwise shift left and right

            //6  9	<   <=   >   >=	Comparisons: less-than, ...
            if ((str == "<") || (str == ">") || (str == "<=") || (str == ">="))
                return 9;
            //7  8 	==   !=	Comparisons: equal and not equal
            if ((str == "=") || (str == "<>"))
                return 8;
            //8  7	&	Bitwise AND
            //9  6	^	Bitwise exclusive OR
            //10 5	|	Bitwise inclusive (normal) OR
            //11 4	&&	Logical 
            if ((str == "and"))
                return 4;
            //12 3	||	Logical OR
            if ((str == "or"))
                return 3;
            //13 2	 ?:   =   +=   -=   *=   /=   %=   &=   |=   ^=   <<=   >>=	Conditional expression (ternary) and assignment operators
            if ((str == ":="))
                return 2;
            //14 1	,	Comma operator
            if ((str == ";"))
                return 1;
            return 0;
        }

        bool op_left_assoc(string str)
        {
            if ((str == "*") || (str == "/") || (str == "+") || (str == "-") ||
                (str == "<") || (str == ">") || (str == "<=") || (str == ">=") ||
                (str == "=") || (str == "<>") ||
                (str == "xor") || (str == "and") || (str == "or") ||
                (str == ";")
                )
                return true;
            //7  8 	==   !=	Comparisons: equal and not equal
            if ((str == ":="))
                return false;

            return false;
        }

        int op_arg_count(string str)
        {
            if ((str == "*") ||
                (str == "/") ||
                (str == "+") ||
                (str == "-") ||
                (str == ">") ||
                (str == "<") ||
                (str == "=") ||
                (str == "<>") ||
                (str == ">=") ||
                (str == "<=") ||
                (str == "or") ||
                (str == "and") ||
                (str == "xor") ||
                (str == ":="))
                return 2;

            return 0;
        }

        bool IsFBDPin(string _pinname, tblFunction _tblfunction, ref tblFormalParameter _tblFormalParameter)
        {
            bool ret = false;
            foreach (tblFormalParameter tblformalparameter in _tblfunction.m_tblFormalParameterCollection)
            {
                if (tblformalparameter.PinName.ToLower() == _pinname.ToLower())
                {
                    _tblFormalParameter = tblformalparameter;
                    ret = true;
                    break;
                }
            }
            return ret;
        }

        public int Add2constantcollection(ValueObj _valueobj)
        {
            int ret;
            if ((ret = CheckValueExistInConstantCollection(_valueobj)) == -1)
            {
                ValueObj valueobj = new ValueObj();
                valueobj.Val.UDINT = _valueobj.Val.UDINT;
                valueobj.ValueType = _valueobj.ValueType;
                constantcollection.Add(valueobj);
                return constantcollection.Count - 1;
            }
            return ret;
        }

        public int Add2stringcollection(string _tok)
        {
            int ret = -1;
            string str = "";
            if (_tok.Length > Common.MAX_STRING_SIZE)
            {
                str = _tok.Substring(0, Common.MAX_STRING_SIZE);
            }
            else
            {
                str = _tok;
            }
            if ((ret = CheckStringExistInStringCollection(str)) == -1)
            {
                stringcollection.Add(str);
                return stringcollection.Count - 1;

            }
            else
            {
                return ret;
            }
        }

        public int CheckValueExistInConstantCollection(ValueObj _valueobj)
        {
            for (int i = 0; i < (int)constantcollection.Count; i++)
            {
                if ((_valueobj.ValueType == constantcollection[i].ValueType) && (_valueobj.Val.UDINT == constantcollection[i].Val.UDINT))
                {
                    return i;
                }
            }
            return -1;
        }

        public int CheckStringExistInStringCollection(string str)
        {

            for (int i = 0; i < (int)stringcollection.Count; i++)
            {

                if (stringcollection[i] == str)
                {
                    return i;
                }
            }
            return -1;

        }

        bool Tokenize(tblController tblcontroller, tblPou tblpou)
        {
            bool _noerror = true;
            tblVariable _tblvariable = new tblVariable();
            tblFormalParameter _tblformalparameter = new tblFormalParameter();
            tblFormalParameter _tblformalparameter1 = new tblFormalParameter();
            tblFunction _tblfunction = new tblFunction();
            bool insideFBD = false;
            ValueObj valueobj = new ValueObj();
            bool ret1, ret2, ret3;
            int i = 0;
            int j = 0;
            string strtok;
            string str = "";
            byte _subproperty = 0;
            string _subpropertytxt = "";
            int ret;
            //CLogicNode* _logicnode = m_LogicNodeList->m_List[_nodeindex];
            //int _nodeno = _logicnode->m_NodeNo;

            try
            {
                i = 0;
                while (i < seperatedlist.Count)
                {
                    strtok = seperatedlist[i];
                    if (ret1 = IsStringValue(seperatedlist[i], ref str))
                    {
                        if ((ret = Add2stringcollection(strtok)) == -1)
                        {
                            _noerror = false;
                            break;
                        }
                        // Add index of string to stringtokenType
                        CTokenOperand tok = new CTokenOperand(seperatedlist[i]);
                        tok.m_token = Token_Type.Token_String;
                        tok.m_Index = ret;
                        tok.m_Type = (int)VarType.STRING;
                        InfixTokenList.Add(tok);
                    }
                    else
                    {
                        if (ret2 = IsValue(seperatedlist[i].ToLower(), ref valueobj))
                        {
                            // Add Index of constant to ConstantTokenType
                            CTokenOperand tok = new CTokenOperand(seperatedlist[i]);
                            tok.m_token = Token_Type.Token_Constant;
                            tok.m_Index = valueobj.Val.LINT;
                            tok.m_Type = valueobj.ValueType;
                            InfixTokenList.Add(tok);
                        }
                        else
                        {
                            if (!((i < (seperatedlist.Count - 1)) && (seperatedlist[i + 1] == "(")) && (ret3 = IsVariable(seperatedlist[i], tblcontroller, tblpou, ref _tblvariable, ref _tblformalparameter,ref  _subproperty ,ref _subpropertytxt)))
                            {
                                // Add Index of constant to ConstantTokenType
                                //wchar_t *str = _propertyname.GetBuffer();
                                //System::string^ str1 = gcnew System::string(str);
                                CTokenVariable tok = new CTokenVariable(seperatedlist[i]);
                                tok.m_token = Token_Type.Token_Variable;
                                tok.Fill(_tblvariable, _tblformalparameter);
                                if (_subpropertytxt != "")
                                {
                                    tok.HasSubPropety = 1;
                                    tok.SubProperty = _subproperty;
                                }
                                else
                                {
                                    tok.HasSubPropety = 0;
                                }
                                InfixTokenList.Add(tok);
                                //
                            }
                            else
                            {
                                if (((i < (seperatedlist.Count - 1)) && ((seperatedlist[i + 1] == "("))) && (ret3 = IsFunctionBlockInstance(seperatedlist[i], tblcontroller, tblpou, ref _tblvariable)))
                                {
                                    if (Global.EWS.m_tblSolution.GetFunctionbyType(_tblvariable.Type).IsFunction)
                                    {
                                        if (Global.EWS.m_tblSolution.GetFunctionbyType(_tblvariable.Type).Extensible)
                                        {
                                            CTokenFunctionEXInstance tok = new CTokenFunctionEXInstance(seperatedlist[i]);
                                            tok.tblvariable = _tblvariable;
                                            tok.tblfunction = Global.EWS.m_tblSolution.GetFunctionbyType(_tblvariable.Type);
                                            InfixTokenList.Add(tok);
                                        }
                                        else
                                        {
                                            CTokenFunctionInstance tok = new CTokenFunctionInstance(seperatedlist[i]);
                                            tok.tblvariable = _tblvariable;
                                            tok.tblfunction = Global.EWS.m_tblSolution.GetFunctionbyType(_tblvariable.Type);
                                            InfixTokenList.Add(tok);
                                        }
                                    }
                                    else
                                    {

                                        CTokenFunctionBlockInstance tok = new CTokenFunctionBlockInstance(seperatedlist[i]);
                                        tok.tblvariable = _tblvariable;
                                        tok.tblfunction = Global.EWS.m_tblSolution.GetFunctionbyType(_tblvariable.Type);
                                        _tblfunction = tok.tblfunction;
                                        InfixTokenList.Add(tok);
                                        //insideFBD = true;
                                        //insideFBDCounter = 0;
                                        if (((seperatedlist.Count - (i + 1) - 2) % 4) == 0)
                                        {
                                            j = (seperatedlist.Count - (i + 1) - 2) / 4;
                                            if ((seperatedlist[i + 1] == "(") && (seperatedlist[seperatedlist.Count - 2] == ")"))
                                            {
                                                insideFBD = true;
                                                for (int k = 0; k < (j - 1); k++)
                                                {
                                                    if (seperatedlist[k * 4 + 5] != ",")
                                                    {
                                                        insideFBD = false;
                                                        break;
                                                    }
                                                }
                                                if (insideFBD)
                                                {
                                                    for (int k = 0; k < j; k++)
                                                    {
                                                        if (seperatedlist[k * 4 + 3] != ":=")
                                                        {
                                                            insideFBD = false;
                                                            break;
                                                        }
                                                    }
                                                    if (insideFBD)
                                                    {
                                                        {
                                                            CToken tok2 = new CToken("(");
                                                            tok2.m_token = Token_Type.Token_LeftParenthisis;
                                                            InfixTokenList.Add(tok2);
                                                        }
                                                        for (int k = 0; k < j; k++)
                                                        {
                                                            if (!((IsFBDPin(seperatedlist[k * 4 + 2], _tblfunction, ref _tblformalparameter1) && IsVariable(seperatedlist[k * 4 + 4], tblcontroller, tblpou, ref _tblvariable, ref _tblformalparameter,ref _subproperty,ref _subpropertytxt))))
                                                            {
                                                                insideFBD = false;
                                                                break;
                                                            }
                                                            else
                                                            {
                                                                CTokenFBDPin tok1 = new CTokenFBDPin(seperatedlist[i]);
                                                                tok1.tblformalparameterPin = _tblformalparameter1;
                                                                tok1.tblvariable = _tblvariable;
                                                                tok1.tblformalparameterVariable = _tblformalparameter;
                                                                if (_subpropertytxt != "")
                                                                {
                                                                    tok1.HasSubPropety = 1;
                                                                    tok1.SubProperty = _subproperty;
                                                                }
                                                                else
                                                                {
                                                                    tok1.HasSubPropety = 0;
                                                                }
                                                                InfixTokenList.Add(tok1);

                                                                // Add Index of constant to Comma TokenType
                                                                CToken tok3 = new CToken(",");
                                                                tok3.m_token = Token_Type.Token_Comma;
                                                                InfixTokenList.Add(tok3);
                                                            }
                                                        }
                                                        if (insideFBD)
                                                        {
                                                            // Add Index of constant to RightParenthesisTokenType
                                                            CToken tok4 = new CToken(")");
                                                            tok4.m_token = Token_Type.Token_RightParenthisis;
                                                            InfixTokenList.Add(tok4);
                                                            i = seperatedlist.Count;
                                                        }

                                                    }

                                                }
                                                else
                                                {
                                                    break;
                                                }
                                            }
                                            else
                                            {
                                                break;
                                            }
                                        }
                                        else
                                        {
                                            break;
                                        }

                                    }

                                    //for each (DBKernel::Model::Function^ function in DBKernel::ContextModel::Context::Instance->Function->Collection)
                                    //{
                                    //    if(function->Type == _type)
                                    //    {
                                    //        if(!function->IsStandard)
                                    //        {
                                    //            System::string^  string1 = function->FunctionName;
                                    //            usedfunctionlist.push_back(string1);
                                    //        }
                                    //        tok->m_tblfunction = function;
                                    //        break;
                                    //    }
                                    //}



                                }
                                else
                                {
                                    if (IsFunction(seperatedlist[i], ref _tblfunction) && (i < (seperatedlist.Count - 1)) && (seperatedlist[i + 1] == "("))
                                    {
                                        // Add Index of constant to FunctionTokenType
                                        if (_tblfunction.Extensible)
                                        {
                                            CTokenFunctionEX tok = new CTokenFunctionEX(seperatedlist[i]);
                                            tok.tblfunction = _tblfunction;
                                            InfixTokenList.Add(tok);
                                        }
                                        else
                                        {
                                            CTokenFunction tok = new CTokenFunction(seperatedlist[i]);
                                            tok.tblfunction = _tblfunction;
                                            InfixTokenList.Add(tok);
                                        }
                                        //
                                    }
                                    // If the token is a function argument separator (e.g., a comma):
                                    else
                                    {
                                        if (seperatedlist[i] == ",")
                                        {
                                            // Add Index of constant to Comma TokenType
                                            CToken tok = new CToken(seperatedlist[i]);
                                            tok.m_token = Token_Type.Token_Comma;
                                            InfixTokenList.Add(tok);

                                            //
                                        }
                                        // If the token is an operator, op1, then:
                                        else
                                        {
                                            if (IsOperator(seperatedlist[i]))
                                            {
                                                // Add Index of constant to OperatorTokenType
                                                if (seperatedlist[i] != ";")
                                                {
                                                    CTokenOperator tok = new CTokenOperator(seperatedlist[i]);
                                                    InfixTokenList.Add(tok);
                                                }
                                                //
                                            }
                                            // If the token is a left parenthesis, then push it onto the stack.
                                            else
                                            {
                                                if (seperatedlist[i] == "(")
                                                {
                                                    // Add Index of constant to LeftParenthesisTokenType
                                                    CToken tok = new CToken(seperatedlist[i]);
                                                    tok.m_token = Token_Type.Token_LeftParenthisis;
                                                    InfixTokenList.Add(tok);
                                                    //
                                                }
                                                // If the token is a right parenthesis:CVar_ANY_ELEMENTARY
                                                else
                                                {
                                                    if (seperatedlist[i] == ")")
                                                    {
                                                        // Add Index of constant to RightParenthesisTokenType
                                                        CToken tok = new CToken(seperatedlist[i]);
                                                        tok.m_token = Token_Type.Token_RightParenthisis;
                                                        InfixTokenList.Add(tok);
                                                        //
                                                    }
                                                    else
                                                    {
                                                        if (seperatedlist[i] == ";")
                                                        {
                                                            CToken tok = new CToken(seperatedlist[i]);
                                                            tok.m_token = Token_Type.Token_Operator;
                                                            InfixTokenList.Add(tok);
                                                        }
                                                        else
                                                        {
                                                            _noerror = false;
                                                            //throw CompilerRunTimeEx(" has error in [" + page_stack->Pop() + "], Unknown token :[" + m_TokenList[i] + "]");

                                                            //_retsstring = msg;
                                                            break;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }

                    }
                    //}

                    i++;
                }
                return _noerror;
            }
            catch (Exception ex)
            {
                parentMainForm.WriteToOutputWindows(ex.Message);
            }
            finally
            {
                seperatedlist.Clear();

            }

            return _noerror;
        }


        bool shunting_yard(string _retsstring)
        {

            Stack<int> _ArgCount = new Stack<int>();
            Stack<bool> _WereValues = new Stack<bool>();
            bool w;
            int argcount = 0;
            Stack<CToken> _Stack = new Stack<CToken>();
            int i = 0;
            int j = 0;
            //string strtok;
            //string str;
            //string str1;
            CToken tok;

            PRNTokenList.Clear();
            for (i = 0; i < InfixTokenList.Count; i++)
            {
                tok = InfixTokenList[i];
                // If the token is a number (identifier), then add it to the output queue.
                if ((tok.m_token == Token_Type.Token_String) || (tok.m_token == Token_Type.Token_Constant) || (tok.m_token == Token_Type.Token_Variable) || (tok.m_token == Token_Type.Token_FBDPin))
                {
                    PRNTokenList.Add(tok);

                    if (_WereValues.Count > 0)
                    {
                        _WereValues.Pop();
                        _WereValues.Push(true);
                    }
                }
                // If the token is a function token, then push it onto the stack.
                else
                {
                    if ((Token_Type.Token_Function == tok.m_token) ||
                        (Token_Type.Token_FunctionEX == tok.m_token) ||
                        (Token_Type.Token_FunctionInstance == tok.m_token) ||
                        (Token_Type.Token_FunctionEXInstance == tok.m_token) ||
                        (Token_Type.Token_FunctionBlockInstance == tok.m_token))
                    {
                        _Stack.Push(tok);
                        _ArgCount.Push(0);
                        // if (!_WereValues.empty())
                        if (_WereValues.Count > 0)
                        {
                            _WereValues.Pop();
                            _WereValues.Push(true);
                        }
                        _WereValues.Push(false);
                    }
                    // If the token is a function argument separator (e.g., a comma):
                    else
                    {
                        if (Token_Type.Token_Comma == tok.m_token)
                        {
                            j = _Stack.Count;
                            bool pe = false;
                            while (_Stack.Count > 0)
                            {
                                if (Token_Type.Token_LeftParenthisis == (_Stack.Peek()).m_token)
                                {
                                    pe = true;
                                    break;
                                }
                                else
                                {
                                    // Until the token at the top of the stack is a left parenthesis,
                                    // pop operators off the stack onto the output queue.
                                    ((CTokenOperator)_Stack.Peek()).NoOfOperands = op_arg_count((_Stack.Peek()).m_str);
                                    PRNTokenList.Add(_Stack.Peek());
                                    _Stack.Pop();
                                }
                            }
                            // If no left parentheses are encountered, either the separator was misplaced
                            // or parentheses were mismatched.
                            if (!pe)
                            {
                                parentMainForm.WriteToOutputWindows("Error: separator or parentheses mismatched", LogLevel.MAX);
                                return false;
                            }
                            w = _WereValues.Peek();
                            _WereValues.Pop();
                            if (w)
                            {
                                argcount = _ArgCount.Peek();
                                _ArgCount.Pop();
                                argcount++;
                                _ArgCount.Push(argcount);
                            }
                            _WereValues.Push(false);
                        }
                        // If the token is an operator, op1, then:
                        else
                        {
                            if (Token_Type.Token_Operator == tok.m_token)
                            {
                                //j = _Stack.GetCount();
                                while (_Stack.Count > 0)
                                {
                                    // While there is an operator token, op2, at the top of the stack
                                    // op1 is left-associative and its precedence is less than or equal to that of op2,
                                    // or op1 has precedence less than that of op2,
                                    // Let + and ^ be right associative.
                                    // Correct transformation from 1^2+3 is 12^3+
                                    // The differing operator priority decides pop / push
                                    // If 2 operators have equal priority then associativity decides.
                                    if ((Token_Type.Token_Operator == _Stack.Peek().m_token) &&
                                        (
                                        (op_left_assoc(tok.m_str) && (op_preced(tok.m_str) <= op_preced(_Stack.Peek().m_str))) ||
                                        (op_preced(tok.m_str) < op_preced(_Stack.Peek().m_str))
                                        )
                                        )
                                    {
                                        // Pop op2 off the stack, onto the output queue;
                                        ((CTokenOperator)_Stack.Peek()).NoOfOperands = op_arg_count(_Stack.Peek().m_str);
                                        PRNTokenList.Add(_Stack.Peek());
                                        _Stack.Pop();
                                    }
                                    else
                                    {
                                        break;
                                    }
                                }
                                // push op1 onto the stack.
                                if (tok.m_str != ";")
                                {
                                    _Stack.Push(tok);
                                }
                            }
                            // If the token is a left parenthesis, then push it onto the stack.
                            else
                            {
                                if (Token_Type.Token_LeftParenthisis == tok.m_token)
                                {
                                    _Stack.Push(tok);
                                }
                                // If the token is a right parenthesis:CVar_ANY_ELEMENTARY
                                else
                                {
                                    if (Token_Type.Token_RightParenthisis == tok.m_token)
                                    {
                                        bool pe = false;
                                        // Until the token at the top of the stack is a left parenthesis,
                                        // pop operators off the stack onto the output queue
                                        //j = _Stack.GetCount();
                                        while (_Stack.Count > 0)
                                        {
                                            //str = _Stack[j - 1];
                                            if (Token_Type.Token_LeftParenthisis == _Stack.Peek().m_token)
                                            {
                                                pe = true;
                                                break;
                                            }
                                            else
                                            {
                                                ((CTokenOperator)_Stack.Peek()).NoOfOperands = op_arg_count(_Stack.Peek().m_str);
                                                PRNTokenList.Add(_Stack.Peek());
                                                _Stack.Pop();
                                            }
                                        }
                                        // If the stack runs out without finding a left parenthesis, then there are mismatched parentheses.
                                        if (!pe)
                                        {
                                            //CParser::SendOutput(_T("Error: parentheses mismatched"));
                                            parentMainForm.WriteToOutputWindows("Error: parentheses mismatched", LogLevel.MAX);
                                            //CParser::SendOutput("Error: parentheses mismatched");
                                            return false;
                                        }
                                        // Pop the left parenthesis from the stack, but not onto the output queue.
                                        _Stack.Pop();

                                        // If the token at the top of the stack is a function token, pop it onto the output queue.
                                        if (_Stack.Count > 0)
                                        {
                                            if ((Token_Type.Token_Function == _Stack.Peek().m_token) ||
                                                (Token_Type.Token_FunctionEX == _Stack.Peek().m_token) ||
                                                (Token_Type.Token_FunctionInstance == _Stack.Peek().m_token) ||
                                                (Token_Type.Token_FunctionEXInstance == _Stack.Peek().m_token) ||
                                                (Token_Type.Token_FunctionBlockInstance == _Stack.Peek().m_token))
                                            {
                                                argcount = _ArgCount.Peek();
                                                _ArgCount.Pop();
                                                w = _WereValues.Peek();
                                                _WereValues.Pop();
                                                if (w)
                                                {
                                                    argcount++;
                                                }

                                                ((CTokenFunction)_Stack.Peek()).m_NoOfFunctionArguments = (byte)argcount;
                                                PRNTokenList.Add(_Stack.Peek());
                                                _Stack.Pop();
                                            }
                                        }
                                    }
                                    else
                                    {

                                        parentMainForm.WriteToOutputWindows("Error: Unknown token " + ((CTokenOperator)tok).m_str, LogLevel.MAX);
                                        return false; // Unknown token
                                    }
                                }
                            }
                        }
                    }
                }

            }
            //When there are no more tokens to read:
            //While there are still operator tokens in the stack:
            //j = _Stack.GetCount();
            while (_Stack.Count > 0)
            {
                //sc = stack[sl - 1];
                if ((Token_Type.Token_LeftParenthisis == _Stack.Peek().m_token) || (Token_Type.Token_RightParenthisis == _Stack.Peek().m_token))
                {
                    //CParser::SendOutput(_T("Error: parentheses mismatched"));
                    _retsstring = "Error: parentheses mismatched";
                    //CParser::SendOutput("Error: parentheses mismatched");
                    return false;
                }
                //str = _Stack[_Stack.GetCount()-1];
                if (Token_Type.Token_Operator == _Stack.Peek().m_token)
                {
                    ((CTokenOperator)_Stack.Peek()).NoOfOperands = op_arg_count(_Stack.Peek().m_str);
                    PRNTokenList.Add(_Stack.Peek());
                    _Stack.Pop();

                }
                else
                {
                    ((CTokenFunction)_Stack.Peek()).m_NoOfFunctionArguments = (byte)argcount;
                    PRNTokenList.Add(_Stack.Peek());
                    _Stack.Pop();
                }

                //_Stack.pop();
            }
            //wcout << " Output : ";
            //for (j = 0; j < PRNTokenList.GetCount(); j++)
            //{
            //    wcout << ((CToken*)PRNTokenList.GetAt(j))->m_str.GetString() << "  ";
            //}
            //wcout << endl;
            //wcout << endl;
            //wcout << endl;

            InfixTokenList.Clear();

            return true;
        }

        ////Homay-01/26/2014
        //public void ExceptionHandler(CompilerRunTimeEx ex)
        //{
        //    SendOutput(_T(ex.GetFullMessage()));
        //}




        //for checking an expression we must check:
        //number of operator arguments are correct
        //number of function arguments with fixed number of arguments are correct
        //for extensible functions which have variable number of arguments arguments must be more than 2




        bool ValidateNumberOfArguments(tblPou tblpou, string _retsstring)
        {
            bool _NoError = true;


            //VarType _vartype ;
            int i, j, count;
            CToken tok = new CToken();
            tok.m_token = Token_Type.Token_Constant;
            //Stack<int> _TokenTypestack = new Stack<int>();
            Stack<CToken> temptokenstack = new Stack<CToken>();
            //stack<gcroot<VarType>> _TokenTypestack;
            //count = m_TokenArray.GetCount();
            try
            {
                count = PRNTokenList.Count;
                for (i = 0; i < count; i++)
                {
                    if (_NoError == false)
                    {
                        break;
                    }
                    //tok = PRNTokenList[i];
                    //m_Tokenqueue.pop();
                    switch (PRNTokenList[i].m_token)
                    {
                        case Token_Type.Token_String:
                        case Token_Type.Token_Variable:
                        case Token_Type.Token_Constant:
                        case Token_Type.Token_FBDPin:
                            temptokenstack.Push(PRNTokenList[i]);
                            break;

                        case Token_Type.Token_Operator:

                            if (((CTokenOperator)PRNTokenList[i]).NoOfOperands > (int)temptokenstack.Count)
                            {
                                _NoError = false;
                                parentMainForm.WriteToOutputWindows("operator " + PRNTokenList[i].m_str + " has wrong number of arguments", LogLevel.MAX);
                                return false;
                                //throw CompilerRunTimeEx(message);
                            }
                            for (j = 0; j < ((CTokenOperator)PRNTokenList[i]).NoOfOperands; j++)
                            {
                                temptokenstack.Pop();
                            }
                            if (PRNTokenList[i].m_str != ":=")
                            {
                                temptokenstack.Push(tok);
                            }


                            break;
                        case Token_Type.Token_FunctionBlockInstance:

                            if (((CTokenFunctionBlockInstance)PRNTokenList[i]).m_NoOfFunctionArguments > ((CTokenFunctionBlockInstance)PRNTokenList[i]).tblfunction.GetAllPossibleInputs())
                            {
                                //CParser::SendOutput(_T("function ")+((CTokenFunction*)tok)->m_tblfunction->FunctionName+_T(" has wrong number of arguments"));
                                parentMainForm.WriteToOutputWindows("function block" + ((CTokenFunctionBlockInstance)PRNTokenList[i]).tblfunction.FunctionName + " has wrong number of arguments");
                                _NoError = false;
                                return false;
                            }
                            else
                            {
                                if (((CTokenFunctionBlockInstance)PRNTokenList[i]).m_NoOfFunctionArguments > temptokenstack.Count)
                                {
                                    parentMainForm.WriteToOutputWindows("function block" + ((CTokenFunctionBlockInstance)PRNTokenList[i]).tblfunction.FunctionName + " has wrong number of arguments");
                                    _NoError = false;
                                    return false;
                                }
                                else
                                {
                                    for (j = 0; j < ((CTokenFunctionBlockInstance)PRNTokenList[i]).m_NoOfFunctionArguments; j++)
                                    {
                                        temptokenstack.Pop();
                                    }

                                    //temptokenstack.Push(tok);
                                }
                            }

                            break;
                        case Token_Type.Token_Function:
                            if (((CTokenFunction)PRNTokenList[i]).m_NoOfFunctionArguments != ((CTokenFunction)PRNTokenList[i]).tblfunction.GetNoOfInputs())
                            {
                                parentMainForm.WriteToOutputWindows("function " + ((CTokenFunction)PRNTokenList[i]).tblfunction.FunctionName + " has wrong number of arguments");
                                _NoError = false;

                                return false;
                            }

                            for (j = 0; j < ((CTokenFunction)PRNTokenList[i]).m_NoOfFunctionArguments; j++)
                            {
                                temptokenstack.Pop();
                            }

                            temptokenstack.Push(tok);
                            break;

                        case Token_Type.Token_FunctionInstance:

                            if (((CTokenFunction)PRNTokenList[i]).m_NoOfFunctionArguments != ((CTokenFunction)PRNTokenList[i]).tblfunction.GetNoOfInputs())
                            {
                                parentMainForm.WriteToOutputWindows("function " + ((CTokenFunction)PRNTokenList[i]).tblfunction.FunctionName + " has wrong number of arguments", LogLevel.MAX);
                                _NoError = false;
                                return false;
                            }

                            for (j = 0; j < ((CTokenFunction)PRNTokenList[i]).m_NoOfFunctionArguments; j++)
                            {
                                temptokenstack.Pop();
                            }

                            // temptokenstack.Push(tok);
                            break;

                        case Token_Type.Token_FunctionEX:
                            if ((((CTokenFunction)PRNTokenList[i]).m_NoOfFunctionArguments < ((CTokenFunction)PRNTokenList[i]).tblfunction.GetNoOfInputs()) ||
                                (((CTokenFunction)PRNTokenList[i]).m_NoOfFunctionArguments > (((CTokenFunction)PRNTokenList[i]).tblfunction.GetNoOfInputs()) + Common.MaxNumberOfExPins - 1))
                            {

                                parentMainForm.WriteToOutputWindows("function " + ((CTokenFunction)PRNTokenList[i]).tblfunction.FunctionName + " has wrong number of arguments", 0);
                                _NoError = false;
                                return false;
                            }

                            for (j = 0; j < ((CTokenFunction)PRNTokenList[i]).m_NoOfFunctionArguments; j++)
                            {
                                temptokenstack.Pop();
                            }

                            temptokenstack.Push(tok);

                            break;
                        case Token_Type.Token_FunctionEXInstance:
                            if ((((CTokenFunction)PRNTokenList[i]).m_NoOfFunctionArguments < ((CTokenFunction)PRNTokenList[i]).tblfunction.GetNoOfInputs()) ||
                                (((CTokenFunction)PRNTokenList[i]).m_NoOfFunctionArguments > (((CTokenFunction)PRNTokenList[i]).tblfunction.GetNoOfInputs()) + Common.MaxNumberOfExPins - 1))
                            {
                                parentMainForm.WriteToOutputWindows("function " + ((CTokenFunction)PRNTokenList[i]).tblfunction.FunctionName + " has wrong number of arguments", 0);
                                _NoError = false;

                                return false;
                            }

                            for (j = 0; j < ((CTokenFunction)PRNTokenList[i]).m_NoOfFunctionArguments; j++)
                            {
                                temptokenstack.Pop();
                            }

                            //temptokenstack.Push(tok);

                            break;
                    }
                }
                if (temptokenstack.Count > 1)
                {
                    temptokenstack.Clear();
                    parentMainForm.WriteToOutputWindows("Unknown Error", 0);
                    _NoError = false;

                    return false;
                }

            }
            catch (Exception ex)
            {
                //ex.POULogic = _poulogic;
                //ex.Message += "[" + tok->m_str + "]";
                //throw ex;
                parentMainForm.WriteToOutputWindows(ex.Message, 0);
            }

            return _NoError;
        }

        bool ValidateArgumentsTypes(tblPou tblpou, int _returntype, string _retsstring)
        {

            bool _NoError = true;

            //int returntype = 0;
            int i, j, count;
            //CToken tok;
            int countsize;
            List<int> vartypelist = new List<int>();
            //VarType _vartype1;
            //VarType _vartype2;
            int _vartype = 0;

            Stack<int> temptokentypestack = new Stack<int>();
            //stack<VarType> _TokenTypestack;
            try
            {
                count = PRNTokenList.Count;
                for (i = 0; i < count; i++)
                {
                    if (_NoError == false)
                    {
                        break;
                    }


                    //m_Tokenqueue.pop();
                    switch (PRNTokenList[i].m_token)
                    {
                        case Token_Type.Token_String:
                        case Token_Type.Token_Variable:
                        case Token_Type.Token_Constant:
                        case Token_Type.Token_FBDPin:
                            temptokentypestack.Push(PRNTokenList[i].GetTokenPinType());
                            break;
                        case Token_Type.Token_Operator:
                            vartypelist.Clear();
                            vartypelist.Add(0);
                            vartypelist.Add(1);

                            vartypelist[1] = temptokentypestack.Pop();
                            vartypelist[0] = temptokentypestack.Pop();
                            if (PRNTokenList[i].CheckArgumentValidity(ref vartypelist, ref _vartype, ref _retsstring))
                            {
                                if (PRNTokenList[i].m_str != ":=")
                                {
                                    temptokentypestack.Push(_vartype);
                                }
                            }
                            else
                            {
                                _NoError = false;
                            }

                            break;
                        case Token_Type.Token_FunctionBlockInstance:
                            vartypelist.Clear();
                            countsize = ((CTokenFunctionBlockInstance)PRNTokenList[i]).m_NoOfFunctionArguments;
                            for (j = 0; j < countsize; j++)
                            {
                                vartypelist.Add(0);
                            }
                            for (j = countsize - 1; j >= 0; j--)
                            {
                                vartypelist[j] = temptokentypestack.Pop();
                            }
                            //if (!PRNTokenList[i].CheckArgumentValidity(ref vartypelist, ref _vartype, ref _retsstring))
                            //{
                            //    _NoError = false;
                            //}
                            for (j = 0; j < countsize; j++)
                            {
                                if (vartypelist[j] == 0)
                                {
                                    _NoError = false;
                                    break;
                                }

                            }

                            break;
                        case Token_Type.Token_Function:
                            vartypelist.Clear();
                            countsize = ((CTokenFunction)PRNTokenList[i]).m_NoOfFunctionArguments;
                            for (j = 0; j < countsize; j++)
                            {
                                vartypelist.Add(0);
                            }
                            for (j = countsize - 1; j >= 0; j--)
                            {
                                vartypelist[j] = temptokentypestack.Pop();
                            }
                            if (PRNTokenList[i].CheckArgumentValidity(ref vartypelist, ref _vartype, ref _retsstring))
                            {
                                ((CTokenFunction)PRNTokenList[i]).OverloadedType = _vartype;
                                temptokentypestack.Push(_vartype);
                            }
                            else
                            {
                                _NoError = false;
                            }
                            break;
                        case Token_Type.Token_FunctionEX:
                            vartypelist.Clear();
                            countsize = ((CTokenFunctionEX)PRNTokenList[i]).m_NoOfFunctionArguments;
                            for (j = 0; j < countsize; j++)
                            {
                                vartypelist.Add(0);
                            }
                            for (j = countsize - 1; j >= 0; j--)
                            {
                                vartypelist[j] = temptokentypestack.Pop();
                            }
                            if (PRNTokenList[i].CheckArgumentValidity(ref vartypelist, ref _vartype, ref _retsstring))
                            {
                                ((CTokenFunctionEX)PRNTokenList[i]).OverloadedType = _vartype;
                                temptokentypestack.Push(_vartype);
                            }
                            else
                            {
                                _NoError = false;
                            }

                            break;
                        case Token_Type.Token_FunctionInstance:
                            vartypelist.Clear();
                            countsize = ((CTokenFunctionInstance)PRNTokenList[i]).m_NoOfFunctionArguments;
                            for (j = 0; j < countsize; j++)
                            {
                                vartypelist.Add(0);
                            }
                            for (j = countsize - 1; j >= 0; j--)
                            {
                                vartypelist[j] = temptokentypestack.Pop();
                            }
                            if (PRNTokenList[i].CheckArgumentValidity(ref vartypelist, ref _vartype, ref _retsstring))
                            {
                                ((CTokenFunctionInstance)PRNTokenList[i]).OverloadedType = _vartype;
                                //temptokentypestack.Push(_vartype);
                            }
                            else
                            {
                                _NoError = false;
                            }

                            break;
                        case Token_Type.Token_FunctionEXInstance:
                            vartypelist.Clear();
                            countsize = ((CTokenFunctionEXInstance)PRNTokenList[i]).m_NoOfFunctionArguments;
                            for (j = 0; j < countsize; j++)
                            {
                                vartypelist.Add(0);
                            }
                            for (j = countsize - 1; j >= 0; j--)
                            {
                                vartypelist[j] = temptokentypestack.Pop();
                            }
                            if (PRNTokenList[i].CheckArgumentValidity(ref vartypelist, ref _vartype, ref _retsstring))
                            {
                                ((CTokenFunctionEXInstance)PRNTokenList[i]).OverloadedType = _vartype;
                                //temptokentypestack.Push(_vartype);
                            }
                            else
                            {
                                _NoError = false;
                            }

                            break;
                    }
                }
                if (temptokentypestack.Count > 0)
                {

                    //returntype = (int)_TokenTypestack.top();
                    //_TokenTypestack.empty();
                    //if (_returntype != VarType.UNKNOWN)
                    //{
                    //    if (_NoError)
                    //    {
                    //        if (_returntype != returntype)
                    //        {
                    //            _retsstring = "Return Type Is not Correct";
                    //            _NoError = false;
                    //        }
                    //    }
                    //}
                }

                return _NoError;
            }
            catch (Exception ex)
            {
                //ex.POULogic = _poulogic;
                //ex.Message += "[" + tok->m_str + "]";
                //throw ex;
                parentMainForm.WriteToOutputWindows(ex.Message, 0);
            }

            return _NoError;

        }

        bool CompileExpression(tblController tblcontroller, tblPou tblpou, int _returntype, SimpleOperation simpleoperation, string _retsstring)
        {
            bool _NoError = true;
            int i, j, count;
            int countsize;
            List<CToken> operandlist = new List<CToken>();
            Stack<CToken> OperandStack = new Stack<CToken>();
            Instruction instruction;
            try
            {
                count = PRNTokenList.Count;
                for (i = 0; i < count; i++)
                {
                    if (_NoError == false)
                    {
                        break;
                    }
                    switch (PRNTokenList[i].m_token)
                    {
                        case Token_Type.Token_String:
                        case Token_Type.Token_Variable:
                        case Token_Type.Token_Constant:
                        case Token_Type.Token_FBDPin:
                            OperandStack.Push(PRNTokenList[i]);
                            break;
                        case Token_Type.Token_Operator:
                            operandlist.Clear();
                            operandlist.Add(new CToken());
                            operandlist.Add(new CToken());
                            operandlist[1] = OperandStack.Pop();
                            operandlist[0] = OperandStack.Pop();
                            instruction = new Instruction();
                            if (PRNTokenList[i].ReturnOperator(ref instruction, operandlist))
                            {
                                if (PRNTokenList[i].m_str != ":=")
                                {
                                    CTokenTempVariable tt = new CTokenTempVariable();
                                    tt.m_token = Token_Type.Token_TempValue;
                                    //tt.type = instruction.OperandList[0].type;
                                    tt.m_Type = instruction.Operator.ReturnType;
                                    tt.m_Index = instruction.OperandList[0].Index;
                                    OperandStack.Push(tt);
                                }
                                simpleoperation.instructionlist.Add(instruction);
                            }
                            else
                            {
                                _NoError = false;
                            }
                            break;
                        case Token_Type.Token_FunctionBlockInstance:
                            operandlist.Clear();
                            countsize = ((CTokenFunctionBlockInstance)PRNTokenList[i]).m_NoOfFunctionArguments;
                            for (j = 0; j < countsize; j++)
                            {
                                operandlist.Add(new CToken());
                            }
                            for (j = countsize - 1; j >= 0; j--)
                            {
                                operandlist[j] = OperandStack.Pop();
                            }
                            //operandlist.Add(PRNTokenList[i]);
                            instruction = new Instruction();
                            if (PRNTokenList[i].ReturnOperator(ref instruction, operandlist))
                            {

                                simpleoperation.instructionlist.Add(instruction);
                            }
                            else
                            {
                                _NoError = false;
                            }
                            break;
                        case Token_Type.Token_Function:
                            operandlist.Clear();
                            countsize = ((CTokenFunction)PRNTokenList[i]).m_NoOfFunctionArguments;
                            for (j = 0; j < countsize; j++)
                            {
                                operandlist.Add(new CToken());
                            }
                            for (j = countsize - 1; j >= 0; j--)
                            {
                                operandlist[j] = OperandStack.Pop();
                            }
                            instruction = new Instruction();
                            if (PRNTokenList[i].ReturnOperator(ref instruction, operandlist))
                            {
                                CTokenTempVariable tt = new CTokenTempVariable();
                                tt.m_token = Token_Type.Token_TempValue;
                               // tt.type = instruction.OperandList[0].type;
                                tt.m_Type = instruction.Operator.ReturnType;
                                tt.m_Index = instruction.OperandList[0].Index;
                                OperandStack.Push(tt);
                                simpleoperation.instructionlist.Add(instruction);
                            }
                            else
                            {
                                _NoError = false;
                            }
                            break;
                        case Token_Type.Token_FunctionEX:
                            operandlist.Clear();
                            countsize = ((CTokenFunctionEX)PRNTokenList[i]).m_NoOfFunctionArguments;
                            for (j = 0; j < countsize; j++)
                            {
                                operandlist.Add(new CToken());
                            }
                            for (j = countsize - 1; j >= 0; j--)
                            {
                                operandlist[j] = OperandStack.Pop();
                            }
                            instruction = new Instruction();
                            if (PRNTokenList[i].ReturnOperator(ref instruction, operandlist))
                            {
                                CTokenTempVariable tt = new CTokenTempVariable();
                                tt.m_token = Token_Type.Token_TempValue;
                                //tt.type = instruction.OperandList[0].type;
                                tt.m_Type = instruction.Operator.ReturnType;
                                tt.m_Index = instruction.OperandList[0].Index;
                                OperandStack.Push(tt);
                                simpleoperation.instructionlist.Add(instruction);
                            }
                            else
                            {
                                _NoError = false;
                            }
                            break;
                        case Token_Type.Token_FunctionInstance:
                            operandlist.Clear();
                            countsize = ((CTokenFunctionInstance)PRNTokenList[i]).m_NoOfFunctionArguments;
                            for (j = 0; j < countsize; j++)
                            {
                                operandlist.Add(new CToken());
                            }
                            for (j = countsize - 1; j >= 0; j--)
                            {
                                operandlist[j] = OperandStack.Pop();
                            }
                            instruction = new Instruction();
                            if (PRNTokenList[i].ReturnOperator(ref instruction, operandlist))
                            {

                                simpleoperation.instructionlist.Add(instruction);
                            }
                            else
                            {
                                _NoError = false;
                            }
                            break;
                        case Token_Type.Token_FunctionEXInstance:
                            operandlist.Clear();
                            countsize = ((CTokenFunctionEXInstance)PRNTokenList[i]).m_NoOfFunctionArguments;
                            for (j = 0; j < countsize; j++)
                            {
                                operandlist.Add(new CToken());
                            }
                            for (j = countsize - 1; j >= 0; j--)
                            {
                                operandlist[j] = OperandStack.Pop();
                            }
                            instruction = new Instruction();
                            if (PRNTokenList[i].ReturnOperator(ref instruction, operandlist))
                            {
                                simpleoperation.instructionlist.Add(instruction);
                            }
                            else
                            {
                                _NoError = false;
                            }
                            break;
                    }
                }
                if (OperandStack.Count == 1 )
                {
                    instruction = new Instruction();
                    operandlist[0] = OperandStack.Pop();
                    ((CTokenTempVariable)operandlist[0]).AddRetrunOperator(ref instruction);
                    simpleoperation.instructionlist.Add(instruction);
                    //returntype = (int)_TokenTypestack.top();
                    //_TokenTypestack.empty();
                    //if (_returntype != VarType.UNKNOWN)
                    //{
                    //    if (_NoError)
                    //    {
                    //        if (_returntype != returntype)
                    //        {
                    //            _retsstring = "Return Type Is not Correct";
                    //            _NoError = false;
                    //        }
                    //    }
                    //}
                }

                return _NoError;
            }
            catch (Exception ex)
            {
                //ex.POULogic = _poulogic;
                //ex.Message += "[" + tok->m_str + "]";
                //throw ex;
                MessageBox.Show(ex.Message);
            }

            return _NoError;

        }

        bool extractOperations(SimpleOperation Parent, List<SimpleOperation> operations, StreamReader streamreader)
        {
            bool ret = true;
            string str = "";
            SimpleOperation simpleoperation = null;
            int linenumber = 0;
            //bool lastoperation = true;
            while (streamreader.Peek() >= 0)
            {
                str = streamreader.ReadLine();
                str = str.Trim();
                linenumber++;
                if (str == "")
                {
                    continue;
                }
                if (IsIf(str))
                {
                    //lastoperation = false;
                    simpleoperation = new IfOperation();
                    simpleoperation.DebugInfo = "if at " + linenumber.ToString() + " : ";
                    ((IfOperation)simpleoperation).GetCondition(str);
                    extractOperations(simpleoperation, ((IfOperation)simpleoperation).ThenOperations, streamreader);
                    operations.Add(simpleoperation);
                }
                else
                {
                    if (IsElse(str))
                    {
                        //lastoperation = false;
                        Parent.DebugInfo = "if at " + linenumber.ToString() + " : ";
                    
                        extractOperations(Parent, ((IfOperation)Parent).ElseOperations, streamreader);
                        ret = true;
                        return ret;
                    }
                    else
                    {
                        if ((IsEndif(str)) && (Parent is IfOperation))
                        {
                            //lastoperation = false;
                            ret = true;
                            return ret;
                            //break;
                        }
                        else
                        {
                            if (IsWhile(str))
                            {
                                //lastoperation = false;
                                simpleoperation = new WhileOperation();
                                simpleoperation.DebugInfo = "while at " + linenumber.ToString() + " : ";

                                ((WhileOperation)simpleoperation).GetCondition(str);
                                extractOperations(simpleoperation, ((WhileOperation)simpleoperation).WhileOperations, streamreader);
                                operations.Add(simpleoperation);
                            }
                            else
                            {
                                if ((IsWend(str)) && (Parent is WhileOperation))
                                {
                                    //lastoperation = false;
                                    ret = true;
                                    return ret;
                                    //break;
                                }
                                else
                                {
                                    simpleoperation = new SimpleOperation();
                                    simpleoperation.DebugInfo = linenumber.ToString() + " : ";

                                    simpleoperation.OperationString = str;
                                    operations.Add(simpleoperation);
                                }
                            }
                        }
                    }
                }

            }
            return ret;

        }

        public bool CompileExpression(SimpleOperation simpleoperation, List<Argumentstruct> _argumentstructlist)
        {
            bool ret = false;
            string _retsstring = "";
            int returntype = 0;
            string str1, str2, str3;
            if (Seperator(((SimpleOperation)simpleoperation).OperationString))
            {
                for (int i = 0; i < seperatedlist.Count; i++)
                {
                    foreach (Argumentstruct argst in _argumentstructlist)
                    {
                        str1 = "@" + argst.Name;
                        str2 = argst.Iuput;
                        str3 = seperatedlist[i];
                        seperatedlist[i] = str3.Replace(str1, str2);
                    }
                }

                if (Tokenize(null, null))
                {
                    if (shunting_yard(_retsstring))
                    {
                        if (ValidateNumberOfArguments(null, _retsstring))
                        {
                            if (ValidateArgumentsTypes(null, returntype, _retsstring))
                            {
                                if (CompileExpression(null, null, returntype, simpleoperation, _retsstring))
                                {
                                    return true;
                                }
                                else
                                {
                                }
                            }
                            else
                            {
                            }
                        }
                        else
                        {
                        }
                    }
                    else
                    {
                    }
                }
                else
                {
                }
            }
            else
            {
            }
            return ret;

        }


        bool CompileSimplleOperation(tblController _tblcontroller, tblPou _tblpou, SimpleOperation simpleoperation)
        {
            bool ret = false;
            string _retsstring = "";
            int returntype = 0;

            if (Seperator(((SimpleOperation)simpleoperation).OperationString))
            {
                if (Tokenize(_tblcontroller, _tblpou))
                {
                    if (shunting_yard(_retsstring))
                    {
                        if (ValidateNumberOfArguments(_tblpou, _retsstring))
                        {
                            if (ValidateArgumentsTypes(_tblpou, returntype, _retsstring))
                            {
                                if (CompileExpression(_tblcontroller, _tblpou, returntype, simpleoperation, _retsstring))
                                {
                                    return true;
                                }
                                else
                                {
                                    parentMainForm.WriteToOutputWindows("Error compiling " + ((SimpleOperation)simpleoperation).OperationString, LogLevel.MAX);
                                }
                            }
                            else
                            {
                                parentMainForm.WriteToOutputWindows("Error compiling Types are not compatible" + ((SimpleOperation)simpleoperation).OperationString, LogLevel.MAX);
                            }
                        }
                        else
                        {
                            parentMainForm.WriteToOutputWindows("Error compiling wrong number of arguments" + ((SimpleOperation)simpleoperation).OperationString, LogLevel.MAX);
                        }
                    }
                    else
                    {
                        parentMainForm.WriteToOutputWindows("Error compiling wrong syntax" + ((SimpleOperation)simpleoperation).OperationString, LogLevel.MAX);
                    }
                }
                else
                {
                    parentMainForm.WriteToOutputWindows("Tokenizer Error", LogLevel.MAX);
                }
            }
            else
            {
                parentMainForm.WriteToOutputWindows("Seperator Error");
            }



            return ret;

        }

        bool CompileOperations(tblController _tblcontroller, tblPou _tblpou, List<SimpleOperation> operations)
        {
            bool ret = true;
            for (int i = 0; i < operations.Count; i++)
            {

                if (operations[i] is IfOperation)
                {
                    if (!CompileSimplleOperation(_tblcontroller, _tblpou, ((IfOperation)operations[i]).QString))
                    {
                        return false;
                    }
                    if (!CompileOperations(_tblcontroller, _tblpou, ((IfOperation)operations[i]).ThenOperations))
                    {
                        return false;
                    }
                    if (!CompileOperations(_tblcontroller, _tblpou, ((IfOperation)operations[i]).ElseOperations))
                    {
                        return false;
                    }
                }
                else
                {
                    if (operations[i] is SimpleOperation)
                    { 
                        if (!CompileSimplleOperation(_tblcontroller, _tblpou, operations[i]))
                        {
                            return false;
                        }
                    }
                }
            }
            return ret;
        }


        public bool CompilePOU(tblPou _tblpou)
        {

            return CompilePOU(Global.EWS.m_tblSolution.GetControllerFromID(_tblpou.ControllerID), _tblpou);

        }

        public bool CompilePOU(tblController _tblcontroller, tblPou _tblpou)
        {
            string filename;
            string Binfilename;
            //OPERAND _operand;
            bool ret = false;
            //int sz = 0;
            try
            {
                // instructionlist.Clear();
                List<SimpleOperation> operations = new List<SimpleOperation>();
                //string str = "";
                filename = Common.ProjectPath + "\\LOGIC";
                filename += "\\";
                //filename += _tblcontroller.DomainID.ToString();
                //filename += "\\";
                filename += _tblcontroller.ControllerName;
                filename += "\\";
                Binfilename = filename;
                filename += _tblpou.pouName + ".st";
                Binfilename += _tblpou.pouName + ".bi";
                parentMainForm.WriteToOutputWindows("Open " + filename);

                //if (_tblpou.Type == (int) PROGRAM_LANGUAGE.ENUM_PROGRAM_LANGUAGE_FBD) 
                //{
                //    using (StreamReader streamreader = new StreamReader(filename))
                //    {
                //        ret = extractOperations(null, operations, streamreader);
                //    }
                //}


                if (File.Exists(filename))
                {
                    using (StreamReader streamreader = new StreamReader(filename))
                    {
                        ret = extractOperations(null, operations, streamreader);
                    }
                }

                if (ret)
                {
                    ret = CompileOperations(_tblcontroller, _tblpou, operations);
                }
                else
                {
                    parentMainForm.WriteToOutputWindows("Error in reading st file" + filename );
                    return false;
                }
                if (ret)
                {
                    try
                    {

                        FileStream _fs = null;
                        BinaryWriter bw = null;
                        if (_fs == null)
                        {
                            try
                            {
                                _fs = new FileStream(Binfilename, System.IO.FileMode.OpenOrCreate, System.IO.FileAccess.Write, System.IO.FileShare.None);
                                bw = new BinaryWriter(_fs);

                            }
                            catch (Exception ex)
                            {
                                throw ex;
                            }
                        }
                        StructFile sf;
                        StructFile sf1;
                        StructFile sf2;
                        DateTime datetime = DateTime.Now;

                        sf1 = new StructFile(typeof(OPERATOR));
                        sf2 = new StructFile(typeof(OPERAND));
                        LogicProgram logicprogram = new LogicProgram();
                        dt_t timestamp;
                        timestamp.dt = 0;
                        timestamp.res = 0;
                        timestamp.Year = (UInt16)datetime.Year;
                        timestamp.Month = (byte)datetime.Month;
                        timestamp.Day = (byte)datetime.Day;
                        timestamp.Hour = (byte)datetime.Hour;
                        timestamp.Minute = (byte)datetime.Minute;
                        timestamp.Second = (byte)datetime.Second;
                        logicprogram.TimeStamp = timestamp.dt;
                        logicprogram.Index = _tblpou.oIndex;
                        logicprogram.Size = GetOpertionsSize(operations);



                        sf = new StructFile(typeof(LogicProgram));
                        logicprogram.Signeture = 0x12345678;
                        logicprogram.Index = _tblpou.oIndex;
                        logicprogram.Type = 0;
                        logicprogram.ProgramType = 1;
                        logicprogram.ProgramLanguage = 0;
                        logicprogram.CycleTimeGroup = 0;

                        logicprogram.Signeture = Common.ntohi(logicprogram.Signeture);
                        logicprogram.Size = Common.ntohi(logicprogram.Size);
                        logicprogram.Index = Common.ntohi(logicprogram.Index);
                        logicprogram.Type = Common.ntohi(logicprogram.Type);
                        logicprogram.ProgramType = Common.ntohi(logicprogram.ProgramType);
                        logicprogram.ProgramLanguage = Common.ntohi(logicprogram.ProgramLanguage);
                        logicprogram.CycleTimeGroup = Common.ntohi(logicprogram.CycleTimeGroup);
                        sf.WriteStructure(bw, (object)logicprogram);

                        for (int i = 0; i < operations.Count; i++)
                        {
                            operations[i].Write2File(bw);
                        }
                        /*
                        if (operations[i] is SimpleOperation)
                        {
                            for (int j = 0; j < operations[i].instructionlist.Count; j++)
                            {

                                sf = new StructFile(typeof(OPERATOR));
                                OPERATOR _operator = operations[i].instructionlist[j].Operator;
                                _operator.ReturnType = Common.ntohi(_operator.ReturnType);
                                _operator.OpCode = Common.ntohi(_operator.OpCode);
                                _operator.operationType = (byte)OPERATION_TYPE.SIMPLE_OPERATION;
                                _operator.Res2 = 2;
                                _operator.Res3 = 3;
                                 sf.WriteStructure( bw, (object)_operator);

                                for (int k = 0; k < operations[i].instructionlist[j].OperandList.Count; k++)
                                {
                                    sf = new StructFile(typeof(OPERAND));
                                    _operand = operations[i].instructionlist[j].OperandList[k];
                                    _operand.Index = Common.ntohl(_operand.Index);
                                    operations[i].instructionlist[j].OperandList[k] = _operand;
                                    sf.WriteStructure( bw, (object)operations[i].instructionlist[j].OperandList[k]);
                                }
                            }
                        }
                         * */

                        bw.Close();
                        bw = null;
                        _fs.Close();

                    }
                    catch (Exception ex)
                    {
                        MessageBox.Show(ex.Message);
                    }
                }
                else
                {
                    parentMainForm.WriteToOutputWindows(filename + " not compiled");
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.Message);
            }


            return ret;
        }

        private int GetOpertionsSize(List<SimpleOperation> operations)
        {
            int logicprogramSize = 0;
            for (int i = 0; i < operations.Count; i++)
            {
                logicprogramSize += operations[i].Size();
            }
            return logicprogramSize;
        }
        
        public bool CompileController(tblController _tblcontroller)
        {
            bool ret = true;

            for (int i = 0; i < _tblcontroller.m_tblPouCollection.Count; i++)
            {
                if (_tblcontroller.m_tblPouCollection[i].pouName != "GLOBAL")
                {
                    if (CompilePOU(_tblcontroller, _tblcontroller.m_tblPouCollection[i]))
                    {

                    }
                    else
                    {
                        ret = false;
                    }
                }
            }

            return ret;
        }
        bool IsIf(string _str)
        {
            bool ret = false;
            _str = _str.ToLower();
            _str = _str.Trim();
            if (_str.StartsWith("if"))
            {
                ret = true;
            }

            return ret;
        }
        bool IsElse(string _str)
        {
            bool ret = false;
            _str = _str.ToLower();
            _str = _str.Trim();
            if (_str.StartsWith("else"))
            {
                ret = true;
            }

            return ret;
        }
        bool IsEndif(string _str)
        {
            bool ret = false;
            _str = _str.ToLower();
            _str = _str.Trim();
            if (_str.EndsWith(";"))
            {
                _str = _str.Substring(0, _str.Length - 1);
            }
            _str = _str.Trim();
            if (_str.StartsWith("end if"))
            {
                ret = true;
            }

            return ret;
        }
        bool IsWhile(string _str)
        {
            bool ret = false;
            _str = _str.ToLower();
            _str = _str.Trim();
            if (_str.StartsWith("while"))
            {
                ret = true;
            }

            return ret;
        }
        bool IsWend(string _str)
        {
            bool ret = false;
            _str = _str.ToLower();
            _str = _str.Trim();
            if (_str.StartsWith("end_while"))
            {
                ret = true;
            }

            return ret;
        }

        public Compiler(MainForm _parent)
        {
            parentMainForm = _parent;
        }
    }
}
